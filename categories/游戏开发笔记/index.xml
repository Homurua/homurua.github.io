<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>游戏开发笔记 on 放学后茶会</title>
        <link>https://wmf.im/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</link>
        <description>Recent content in 游戏开发笔记 on 放学后茶会</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 15 Apr 2022 09:21:57 +0800</lastBuildDate><atom:link href="https://wmf.im/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>浅谈游戏开发中的浮点数与定点数</title>
        <link>https://wmf.im/p/%E6%B5%85%E8%B0%88%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%AE%9A%E7%82%B9%E6%95%B0/</link>
        <pubDate>Fri, 15 Apr 2022 09:21:57 +0800</pubDate>
        
        <guid>https://wmf.im/p/%E6%B5%85%E8%B0%88%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%AE%9A%E7%82%B9%E6%95%B0/</guid>
        <description>&lt;p&gt;　　使用浮点数表示小数在各种开发中都非常常用，但是在游戏开发中有一些场合需要使用整数来模拟定点数代替浮点数表示小数，本篇会简单讲解这两种表示小数方法的区别和使用场景。&lt;/p&gt;
&lt;h2 id=&#34;浮点数&#34;&gt;浮点数&lt;/h2&gt;
&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;
&lt;p&gt;　　现行的浮点数通用运算标准是由 IEEE 委员会在上世纪八十年代制定的，被称为 IEEE 754 标准，它规定了浮点数需要使用 $v$ = $(-1)^s$ * $f$ * $2^e$ 的形式来表示一个小数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s 代表符号位（sign），当 s 为 1 时 v 是负数，s 为 0 时 v 是正数。&lt;/li&gt;
&lt;li&gt;f 代表小数（fraction）部分。&lt;/li&gt;
&lt;li&gt;e 代表指数（exponent）部分，它可以为负数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　一般在单精度浮点数（float）中 s 占 1 位，e 占 8 位，f 占 23 位，一共 32 位。在双精度浮点数（double）中 s 占 1 位，e 占 11 位，f 占 52 位，一共 64 位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E8%B0%88%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%AE%9A%E7%82%B9%E6%95%B0/float_bits.jpg&#34;
	width=&#34;2724&#34;
	height=&#34;362&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E8%B0%88%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%AE%9A%E7%82%B9%E6%95%B0/float_bits_hu4d4ab0feec922d9da3e697be7e98f6d2_25233_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E6%B5%85%E8%B0%88%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8E%E5%AE%9A%E7%82%B9%E6%95%B0/float_bits_hu4d4ab0feec922d9da3e697be7e98f6d2_25233_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;float_bits&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;752&#34;
		data-flex-basis=&#34;1805px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;跨平台&#34;&gt;跨平台&lt;/h3&gt;
&lt;p&gt;　　虽然有了 IEEE 754 标准，但是各家在实现上还是有一些区别，尤其是舍入规则上。这导致了跨平台，尤其是跨 CPU 架构的情况下，执行同一个浮点数计算得到的结果可能不一样。相关内容可以参考这篇回答，&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/20963419/cross-platform-floating-point-consistency&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Cross Platform Floating Point Consistency&lt;/a&gt;。&lt;br&gt;
　　由于大部分情况下的开发都不太需要浮点数满足跨平台一致性，所以一般功能的日常开发并无什么影响，但是游戏开发中如果使用了帧同步技术的话，微小的计算差异可能会被慢慢累积，最后变得使得多端的状态不一致。&lt;/p&gt;
&lt;h2 id=&#34;定点数&#34;&gt;定点数&lt;/h2&gt;
&lt;p&gt;　　定点数是指小数点固定的数，一般是通过为整数约定一个固定的小数点位置来模拟小数。早期因为 CPU 的浮点计算能力比较差，定点数被广泛使用，比如经典游戏 DOOM 中就使用了定点数。&lt;br&gt;
　　由于现代 CPU 的浮点计算能力大幅提升，绝大多数情况下已经完全不需要使用定点数模拟小数了，跨平台小数计算一致性就是定点数为数不多的使用场景之一。&lt;br&gt;
　　定点数的实现其实不太难，一般在精度要求不高的情况下，使用 32 位整数模拟一个 16.16 的小数即可满足大部分需求，来看一下 &lt;a class=&#34;link&#34; href=&#34;https://github.com/id-Software/DOOM&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DOOM&lt;/a&gt; 的实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// m_fixed.h
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define FRACBITS   16
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define FRACUNIT   (1&amp;lt;&amp;lt;FRACBITS)
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define MAXINT     ((int)0x7fffffff)
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define MININT     ((int)0x80000000)
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;FixedMul&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;FixedDiv&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;FixedDiv2&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// m_fixed.c
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;FixedMul&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRACBITS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;FixedDiv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;abs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;abs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;MININT&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAXINT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FixedDiv2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;FixedDiv2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FRACUNIT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;2147483648.0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;2147483648.0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;I_Error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;FixedDiv: divide by zero&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　m_fixed 提供了乘除法的接口，举一个例子来测试一下定点数和浮点数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;n&#34;&gt;fixed_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FixedDiv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// n = 209715
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;fixed: %lf&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;65536.0f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// fixed: 3.199997
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;float: %lf&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;5.0f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// float: 3.200000
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　可以看到定点数的精度是不如浮点数的，并且使用同样大小的空间时，定点数可以表示的范围也远不及浮点数。&lt;br&gt;
　　定点数的最大的优势是自主实现，规则可控，这就意味着可以非常轻易的做到跨平台的一致性。在部分开发场景下，一致性远比高精度更加重要。&lt;/p&gt;</description>
        </item>
        <item>
        <title>游戏开发中的存储系统设计</title>
        <link>https://wmf.im/p/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</link>
        <pubDate>Fri, 08 Apr 2022 22:38:27 +0800</pubDate>
        
        <guid>https://wmf.im/p/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</guid>
        <description>&lt;p&gt;　　游戏开发中如何进行高效稳定的数据存取，一直是非常重要的问题。本篇中会尝试分析一下常见的存储方案。&lt;/p&gt;
&lt;h2 id=&#34;数据库选择&#34;&gt;数据库选择&lt;/h2&gt;
&lt;p&gt;　　如果是早几年的话，这基本上是个不需要讨论的问题，因为 MySQL 是当时绝对的主流选择，但是最近几年这种情况发生了一些变化，让数据库选择有了更多的方案。&lt;/p&gt;
&lt;h3 id=&#34;直接读写文件&#34;&gt;直接读写文件&lt;/h3&gt;
&lt;p&gt;　　使用直接读写文件这种方式来保存游戏内数据的公司应该很少很少了，可能只有一些还抱着祖传代码不想撒手的公司还在用。&lt;br&gt;
　　不过大部分公司在保存日志或者是战斗录像这种单个文件内容比较大，并且不会修改的数据的时候都还会使用这种方法，尤其是对时间久的一些日志，基本上不会查询，只做留档使用了。&lt;br&gt;
　　采用这种方式的实现，一般是将每种类型数据中每一个 key 作为文件名，数据作为文件内容来存储。每种数据可以使用一到多个文件夹来管理。创建和更新数据的时候一般使用某种序列化方式将内存中需要保存的数据打包，然后写入到适当的目录下。读取数据的时候通过数据类型和 key 找到对应目录下的文件，通过文件 I/O 将其读入内存中，再反序列化得到数据。&lt;/p&gt;
&lt;h3 id=&#34;mysql&#34;&gt;MySQL&lt;/h3&gt;
&lt;p&gt;　　凭借开源且免费的特点，MySQL 逐渐变成了关系型数据库的代表。在 NoSQL 数据库兴起之前，MySQL 基本上是有统治级别的使用率。&lt;br&gt;
　　MySQL 虽强，但是这几年它增加了一批非常有竞争力的对手，也令他的统治地位有点一些动摇。不过 MySQL 目前也依然活跃在相当大比例的游戏公司中，毕竟大部分公司对 MySQL 都有丰富的使用经验，很多坑也都踩过填过了，选用一个成熟可靠的数据库也是很正常的事情。&lt;br&gt;
　　使用 MySQL 存储数据的话，有两种用法，第一是完全按照关系型数据库那种每张表分字段的方法。还有一种是当作 key - value 数据库来用，每张表只有两个字段，key 和 value，会把本张表中要保存的所有字段都使用一种方式序列化成一个值，存入一个 blob 类型的 value 中，不过这种方法在数据更新的时候没办法单独更新字段，只能再次将 value 完整序列化替换掉旧值。&lt;/p&gt;
&lt;h3 id=&#34;redis&#34;&gt;Redis&lt;/h3&gt;
&lt;p&gt;　　Redis 应该是后起之秀里面攻势最猛的了，因为它的性能优势，使它深受对实时性要求很高的游戏行业青睐。&lt;br&gt;
　　它同样开源免费，而且因为全部数据都在内存中，所以它无论是读取还是写入，都对传统的磁盘数据库有碾压的表现。当然缺点也很明显，毕竟相同单位大小的内存比硬盘可是贵的多了，而且系统和硬件支持内存的容量上限也远远小于硬盘。同时数据在内存里也并不安全，如果需要开持久化的话，它的性能会有一些下降。&lt;br&gt;
　　在 Redis 中保存数据一般采用 &amp;ldquo;数据类型 + uid&amp;rdquo; 作为 key，每个数据是一个哈希表，其中保存了它的所有字段。同时 Redis 也可以非常方便的保存一些全局数据。&lt;/p&gt;
&lt;h3 id=&#34;mongodb&#34;&gt;MongoDB&lt;/h3&gt;
&lt;p&gt;　　如果说 Redis 是 NoSQL 数据库中发展最好的内存数据库，那么 MongoDB 就是 NoSQL 数据库中发展最好的磁盘数据库了，在游戏公司中使用的更多。&lt;br&gt;
　　模式自由（Schema-free）的数据库对游戏公司的业务是非常合适的。不再需要做业务的时候经常改表的字段了。最重要的是，游戏公司的业务基本上是不需要使用关系型数据库提供的复杂特性，也不需要使用 SQL 进行复杂的查询，这使得关系型数据库的优势难以发挥。&lt;br&gt;
　　不过它也有很多为人诟病的地方，比如相对一些成熟的老牌数据库来说稳定性，性能，内存占用等方面都有一些劣势，但是这些年随着版本不断迭代，各方面进步都很大，已经长期霸占 &lt;a class=&#34;link&#34; href=&#34;https://db-engines.com/en/ranking&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DB Engine&lt;/a&gt; 的第五名了。&lt;br&gt;
　　MongdoDB 也是 key - value 数据库，不过它在外层有一个集合的概念，基本上相当于关系型数据库中的表了，使用的时候将不同功能的数据放在不同的集合中即可。&lt;/p&gt;
&lt;h2 id=&#34;存储方案&#34;&gt;存储方案&lt;/h2&gt;
&lt;p&gt;　　一个完整开发的较大规模的游戏项目，基本上不会只是用一种存储数据的方式。因为游戏中对各种数据的使用和保存方式都有很大区别，这导致了很难有一种完全的方法可以搞定所有数据的存储。所以一般都是采用多种方式混合的数据存储方案。&lt;/p&gt;
&lt;h3 id=&#34;加载数据&#34;&gt;加载数据&lt;/h3&gt;
&lt;p&gt;　　数据被加载大概有两种处理方式，启服时全量加载不释放，按需加载使用完释放。&lt;br&gt;
　　适合全量加载不释放的数据必须规模不是太大，且要使用非常频繁，这样才有常驻内存中的价值。一般都是用来保存进程的全局数据。&lt;br&gt;
　　按需加载使用完释放，一般用来保存跟个体有关的数据，这部分数据当个体没有操作的时候，大部分情况下是完全用不到的。这种形式可以再加上一层缓存层来加快热点数据加载，这个缓存层如果需求比较简单可以自己实现，如果需要一些高级功能，可以使用 Redis 来做。&lt;/p&gt;
&lt;h3 id=&#34;写入数据&#34;&gt;写入数据&lt;/h3&gt;
&lt;p&gt;　　写入数据的方式大概有四种，每次修改直接落地，定时全量落地队列，定时脏数据落地队列，数据离线全量落地。&lt;br&gt;
　　每次修改直接落地的代价比较大，要严格控制这类操作的使用范围，一般只有高优先级的操作引起的数据变更会考虑使用每次修改直接落地的操作。&lt;br&gt;
　　定时全量落地队列，是指在某个对象的数据发生变更以后，将其加入到一个变更对象列表中，然后每隔一段时间，将列表中对象的所有数据进行一次落地。&lt;br&gt;
　　定时脏数据落地队列，是指在对象的某个数据发生变更以后，将对象和修改的字段加入到变更对象列表中，然后每隔一段时间，将列表中的变更对象被修改字段的数据落地。&lt;br&gt;
　　数据离线全量落地，是某个对象要从内存中删除这种情况，在删除之前会对这个对象进行一次全量的保存，一般作为别的方案的保底。&lt;/p&gt;
&lt;h2 id=&#34;数据分类&#34;&gt;数据分类&lt;/h2&gt;
&lt;p&gt;　　选择存储方案需要根据实际需求来考量，数据的不同使用场景和范围，都对应了不同的存储方案。&lt;/p&gt;
&lt;h3 id=&#34;玩家数据&#34;&gt;玩家数据&lt;/h3&gt;
&lt;p&gt;　　游戏中玩家数据的总量是很大的，即使是日活月活都不太高的游戏，它的注册用户可能也是很惊人的一个量。这就导致了玩家数据在起服时全部加载到内存中变成不现实的事情。&lt;br&gt;
　　玩家的数据大概有两类组成，第一类是别的系统可能会在玩家离线的时候读取的部分，可能有的是玩家的名字，uid，签名，等级，所属工会等基本信息。另一类是别的系统不会读取，只有玩家自己登录以后才会使用的数据，比如背包中的物品数量，经验值，体力值这些。在开发中有时也会称第一类为对外数据，第二类为对内数据。&lt;br&gt;
　　对内数据和对外数据因为使用场景不同，一般会分表来保存，不放在一起，方便读取，加载策略也有一些区别。对内数据只有在玩家登录的时候才会从硬盘上加载进游戏服的内存中，玩家下线以后就可以释放掉这部分内存了，一般不会缓存这部分数据，而是可能会做一个延迟删除对象的设定，来应对玩家可能的立马再次上线。对外数据经常要被其它系统读取，比如好友之类的系统，一些高等级玩家的数据可能会经常被访问，所以一般会使用带缓存的按需加载。&lt;br&gt;
　　玩家数据的变更是非常频繁的，一个在线玩家即使是完全不做任何操作，可能也会有一些定时器会修改他的数据。如果每次的修改都落地到硬盘显然是不现实的。一般采用定时脏数据落地队列的方案进行数据更新，有时也会再加上数据离线全量落地作为保底。&lt;/p&gt;
&lt;h3 id=&#34;全局数据&#34;&gt;全局数据&lt;/h3&gt;
&lt;p&gt;　　游戏中有一些全局数据，这些数据一般单个服务器只有一份，数据量不会太大，但是访问频率很高。像是当前开放的活动中的数据，以及一些功能的全服状态。&lt;br&gt;
　　这种全局数据直接在启动时全部加载进内存即可，整个功能的开放周期中都存在于内存里，数据保存方式可以按需选择，一般也用定时脏数据落地队列即可。&lt;/p&gt;
&lt;h3 id=&#34;功能数据&#34;&gt;功能数据&lt;/h3&gt;
&lt;p&gt;　　很多功能性系统的数据是会脱离玩家数据单独保存的，比如像公会，聊天这种，这部分数据相对比较独立，一般只有自己系统会用。&lt;br&gt;
　　这些系统的总数据量可能会非常大，尤其是像需要保存全部记录的聊天系统，会越来越大。这些数据如果也是启动时全部加载是不太现实的，一般使用按需加载使用完释放，并且要加上缓存系统，因为这些数据会有明显的优先级，比如高排名的公会信息可能经常被查看，同样在一个会话中最新的聊天记录也会被经常查看。&lt;/p&gt;
&lt;h3 id=&#34;日志数据&#34;&gt;日志数据&lt;/h3&gt;
&lt;p&gt;　　日志类数据不仅包含了日志，还有类似战斗录像这种数据。如果说其它数据只是比较大的话，那日志类数据就真的是巨大了，远超其它数据很多个数量级，这就导致了它需要一些特殊的手段来处理。&lt;br&gt;
　　一般处理日志类数据有两种方法，存数据库，或者是把每小时的日志存进一个独立文件里。存数据库可以方便直接进行查询，不过用这种方法的公司比较少，因为日志数据实在是太多了。存成文件的好处是，可以直接通过目录查看，清晰直观，也不需要生产环境的数据库权限就可以查看这些文件，如果需要进行分析，可以使用一些日志分析工具进行后期分析。&lt;br&gt;
　　有一些项目要求只要保存一定时间以内的日志即可，比如 30 天，这种就比较简单，每天把最后一天的日志删除即可，总量一直在一个可以接受的范围内。但是有一些项目是需要永久保存日志的，这种需求就需要将非临近日期的日志进行二次处理，一般是将其打包压缩，然后可以选择一种更加便宜的存储介质来保存，比如说磁带。&lt;/p&gt;</description>
        </item>
        <item>
        <title>浅析游戏开发中的寻路算法</title>
        <link>https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/</link>
        <pubDate>Tue, 05 Apr 2022 16:28:27 +0800</pubDate>
        
        <guid>https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;p&gt;　　游戏开发中，只要有地图，基本上就避免不了要实现寻路。哪怕没有给玩家提供寻路功能，游戏中的 AI 实现也需要借助寻路来移动。&lt;/p&gt;
&lt;h2 id=&#34;地图建模&#34;&gt;地图建模&lt;/h2&gt;
&lt;p&gt;　　不管是什么形式的地图，拿到它的第一步应该是设法为其建模，一份无法建模的地图数据是不能进行计算的，建模的目的是为了得到一个方便寻路算法使用的模型。&lt;br&gt;
　　常用的寻路建模方式有划分格子（Grid），放置路点（WayPoint），生成导航网格（NavMesh）这三种。&lt;/p&gt;
&lt;h3 id=&#34;划分格子&#34;&gt;划分格子&lt;/h3&gt;
&lt;p&gt;　　将地图分割成紧密相邻的若干个大小形状完全相同的正多边形，一般会使用是正方形，偶尔会用正六边形，基本没有别的形状的实现。&lt;br&gt;
　　一般会以地图上的对象可以通行的最小宽度为单位来划分格子，使用二维数组即可方便保存和读取建模后的数据。使用不同的数字可以标识出地图格子不同的状态，比如可以简单的将 1 作为可以行走的格子，0 作为不可行走的格子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Lua&#34; data-lang=&#34;Lua&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　划分格子一般用在二维地图上，它的优点是实现比较简单，最直观，也不需要额外的工具辅助修改。缺点是内存开销会比较大，内存占用是随着地图大小线性增长的。&lt;/p&gt;
&lt;h3 id=&#34;放置路点&#34;&gt;放置路点&lt;/h3&gt;
&lt;p&gt;　　路点顾名思义就是路上的点，在地图上根据需求在所有需要寻路的区域放置路点。路点一般是需要人工选择位置放置的，不过不用担心，一般会有策划同学负责搞这个，233。&lt;br&gt;
　　路点的总集合在 Lua 中一般可以使用一个 Table 来记录，每个路点包含了两份数据，自己的位置和从自己出发可以去的点，可达点还需要记录到它的路径开销，这个路径开销并不一定是简单的坐标距离计算，可以是考虑了地图点优先级的开销。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Lua&#34; data-lang=&#34;Lua&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;waypoint&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　路点寻路的缺点是点需要手工配置，经常会有一些点因为配的不太好，比如连通性配置有问题之类的，导致寻路的效果很奇怪，比如会莫名其妙绕路。而且因为对象一开始大概率不会正好在一个路点上，所以还要解决怎么从当前位置去到离得最近的路点这个问题。一般如果地图的路点不多的话，可以遍历路点，找到一个离自己近且中间无阻挡的路点作为起始点，直线跑过去以后开始后续的寻路。&lt;br&gt;
　　路点的优点是相比划分格子，因为路点的数量会少得多，所以它占用的内存会少，而且因为点少，所以它在后续配合算法寻路时效率也更高。还有一个优点是有时候策划想要对象在寻路时按照他配置的线路跑，比如在城市中寻路，有的策划喜欢让角色在路上跑时可以跑在路中间，而不是沿着建筑物边缘跑最更近的路程。&lt;/p&gt;
&lt;h3 id=&#34;导航网格&#34;&gt;导航网格&lt;/h3&gt;
&lt;p&gt;　　导航网格是这几种里面最复杂的，使用了非常多的前端技术来处理地图。有一个非常广泛使用的开源库 &lt;a class=&#34;link&#34; href=&#34;https://github.com/recastnavigation/recastnavigation&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;recastnavigation&lt;/a&gt;，基本上是业界标杆水平。&lt;br&gt;
　　导航网格的核心是将地图分为凸多边形网格（Poly Mesh），之所以这样做是因为凸多边形有一个特性，在它内部包括边缘任意取两个点连线都不出超出它本身的范围。Poly 是不带高度的，每个 Poly 会进一步划分成若干个三角形，每个三角形可以保证是一个平直面。划分的三角形可以保存下来用于寻路。整个处理过程有一篇文章写的很好，&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/35100455&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;游戏的寻路导航 1：导航网格&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navmesh.jpg&#34;
	width=&#34;1678&#34;
	height=&#34;1217&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navmesh_hue8c561fbcfc28eb437246c9f5e9438e9_195940_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navmesh_hue8c561fbcfc28eb437246c9f5e9438e9_195940_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;recastnavigation&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;330px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　导航网格的优点是它可以很好的用在 3D 地图上。缺点是概念比较难以理解，这导致难以做一些需求定制，同时处理很大的地图时生成结果的过程非常慢。&lt;/p&gt;
&lt;h2 id=&#34;寻路算法&#34;&gt;寻路算法&lt;/h2&gt;
&lt;p&gt;　　虽然标题是寻路算法，但是现在才真正开始讲寻路算法。&lt;br&gt;
　　寻路算法是需要基于上述几种寻路数据建模的结果来计算的。理论上任何一种寻路算法都可以跟上面的任何一种建模方式配合使用。&lt;/p&gt;
&lt;h3 id=&#34;一些概念&#34;&gt;一些概念&lt;/h3&gt;
&lt;p&gt;　　为了更好的了解寻路算法，首先要简单说几个概念。&lt;br&gt;
　　曼哈顿距离，是一种在大城市估算城市距离的方法，它假设开始点和结束点直接都是高楼大厦，无法对角线移动。它的计算很简单，在 2D 坐标轴中两个点的曼哈顿距离就是它们在 x 轴上的距离 + 它们在 y 轴上的距离。&lt;br&gt;
　　欧几里得距离，就是两个点之间的真实距离，它不做任何移动方向上的限制，直接使用勾股定理计算两个点的直线距离。&lt;br&gt;
　　启发式函数，用来进行一些寻路中需要参考的值的预估，在算法中使用不同的启发式函数，可以得到不同的寻路结果。&lt;br&gt;
　　开放集合（OpenList），保存的是目前需要关注的点，一般是当前寻路点周围的点。在寻路计算中经常需要从开放集合中取出经过启发式函数计算的估值最小的点，所以开放集合一般使用有序的数据结构实现。&lt;br&gt;
　　封闭集合（CloseList），保存的是所有已经被启发式函数计算过估值的点，当一个点在寻路计算中被处理完毕以后，它会被放在这个集合中。因为经常需要判断一个点是否在封闭集合中，所以它一般使用哈希表之类的数据结构实现。&lt;/p&gt;
&lt;h3 id=&#34;贪心算法&#34;&gt;贪心算法&lt;/h3&gt;
&lt;p&gt;　　贪心两个字是指算法不做长期的的规划，而仅仅着眼于眼前。它每次选择下一步的点时，都直接选择待选点中通过启发式函数计算开销最低的点。如果在没有任何阻挡的情况下，那么这样是路径最短的，但是如果有了阻挡以后，这样做往往可能会选择出一条非最优路线。&lt;br&gt;
　　贪心算法的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先将起点设为当前点，并且将它加入封闭集合中。&lt;/li&gt;
&lt;li&gt;依次处理当前点的所有可达点中不在封闭集合里的点，将其前置点设为当前点，然后检查它是否在开放集合中，如果不在则计算其预估开销，并且将其加入开放集合中。&lt;/li&gt;
&lt;li&gt;检查开放集合，如果为空，则地图搜索已经结束了，跳至步骤 5。&lt;/li&gt;
&lt;li&gt;如果开放集合不为空，则取出其中预估开销最小一个点设为当前点，比较它的位置是否与目标终点一致，如果一致，则搜索结束，否则将它加入到封闭集合中，重复步骤 2。&lt;/li&gt;
&lt;li&gt;当搜索结束时，如果当前点的位置不是目标终点，那么寻路失败。否则从当前点也就是终点开始一直找前置点，这条线路的逆序就是寻路的结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　接下来看一个贪心算法的搜索步骤例子，例子使用曼哈顿距离作为期望开销，在图中使用中间有点的格子代表了该格子已经被加入到了封闭列表中，有路径数值的格子代表了当前在开放列表中的格子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_greedy.jpg&#34;
	width=&#34;2888&#34;
	height=&#34;3844&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_greedy_huc8dd876172758c362556d8267a682a8a_359902_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_greedy_huc8dd876172758c362556d8267a682a8a_359902_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;navi_greedy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;75&#34;
		data-flex-basis=&#34;180px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到贪心算法导致了从起点开始没有直接向下，而是一路向右，直到碰到了阻挡又绕了一圈过去，最终找到了目标点，但是没有得到最佳的路线。&lt;/p&gt;
&lt;h3 id=&#34;a-算法&#34;&gt;A* 算法&lt;/h3&gt;
&lt;p&gt;　　A* 算法应该是使用最广泛的寻路算法了，它兼顾了性能与路径质量，同时实现也比较简单，只比贪心复杂了一点点。&lt;br&gt;
　　A* 算法的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先将起点设为当前点，并且将它加入封闭集合中。&lt;/li&gt;
&lt;li&gt;依次处理当前点的所有可达点中不在封闭集合里的点，检查其是否在开放集合中，如果不在则将其前置点设为当前点，计算其总开销，并且加入开放集合中。如果它本来就在开放集合中，则以当前点作为它的前置点再计算一次它的总开销，如果比之前的少，则将它的前置点改为当前点并且更新它的总开销。&lt;/li&gt;
&lt;li&gt;检查开放集合，如果为空，则地图搜索已经结束了，跳至步骤 5。&lt;/li&gt;
&lt;li&gt;如果开放集合不为空，则取出其中总开销最小的一个点设为当前点，比较它的位置是否与目标终点一致，如果一致，则搜索结束，否则将它加入到封闭集合中，重复步骤 2。&lt;/li&gt;
&lt;li&gt;当搜索结束时，如果当前点的位置不是目标终点，那么寻路失败。否则从当前点也就是终点开始一直找前置点，这条线路的逆序就是寻路的结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　可以看到，A* 算法与贪心算法的区别都在步骤 2 里，主要有两点，首先 A* 算法中是使用的两个路径和来计算的，其次 A* 算法在处理已经在开放集合中的可达点时，会比较它当前的总开销与以自己为前置点的总开销，当以自己为前置点的总开销小的时候才会更新可达点的前置点。&lt;br&gt;
　　接下来使用 A* 算法处理刚刚贪心算法处理过的那个问题，图中的 h 为预估开销，g 为前置路径开销，f 为总开销，也就是 h 和 g 的总和。当计算当前点的可达点时，会计算出以自己为前置点的开销，列出 h 和 g，不是当前点的可达点的点只列出它目前的开销和，方便比较。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_1.jpg&#34;
	width=&#34;2884&#34;
	height=&#34;964&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_1_huc8dd876172758c362556d8267a682a8a_100418_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_1_huc8dd876172758c362556d8267a682a8a_100418_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;navi_a_star_1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;299&#34;
		data-flex-basis=&#34;718px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到 A* 寻发在一开始一样是一路向右边走，遇到阻挡以后，此时开放集合中有六个点，在第三张图里分成了三列，每一列上下两个点的父节点都是它们中间那个点，这时六个点的总开销都是 6。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_2.jpg&#34;
	width=&#34;2884&#34;
	height=&#34;964&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_2_huc8dd876172758c362556d8267a682a8a_95413_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_2_huc8dd876172758c362556d8267a682a8a_95413_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;navi_a_star_2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;299&#34;
		data-flex-basis=&#34;718px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　因为开放集合里的点路径相等，所以随机取一个点作为当前点，最左边图中假设取到了右上角的点。可以看到它只有一个相邻点可以走并且不在封闭集合中，但是它从本点走过去的路径和是 8，大于其原来的 6，所以不做更新操作。中间的图假设取到了下面的点，也是一样的情况。现在开放集合中还剩下四个点，并且路径和都为 6。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_3.jpg&#34;
	width=&#34;2884&#34;
	height=&#34;964&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_3_huc8dd876172758c362556d8267a682a8a_90744_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_3_huc8dd876172758c362556d8267a682a8a_90744_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;navi_a_star_3&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;299&#34;
		data-flex-basis=&#34;718px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　这三张图处理的是开放集合中，处于中间列的两个点的情况，跟上面的情况一样，也找不到更短的路径，不做任何更新，只把自己加入到封闭集合中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_4.jpg&#34;
	width=&#34;2888&#34;
	height=&#34;964&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_4_huc8dd876172758c362556d8267a682a8a_81362_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_4_huc8dd876172758c362556d8267a682a8a_81362_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;navi_a_star_4&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;299&#34;
		data-flex-basis=&#34;719px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　继续看后续的操作，这三种图中，第一张图处理第一个点，它周围已经没有任何不在封闭集合中的点了，无法进行操作，直接把自己放入封闭集合中。然后处理第一列下面的那个点，将它更下面的点加入到开发集合中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_5.jpg&#34;
	width=&#34;2884&#34;
	height=&#34;964&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_5_huc8dd876172758c362556d8267a682a8a_95371_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_5_huc8dd876172758c362556d8267a682a8a_95371_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;navi_a_star_5&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;299&#34;
		data-flex-basis=&#34;718px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　接下来的事情就顺理成章了，开放集合中只有一个点，一直走下去就可以了。当前节点位置等于目标点时，说明寻路结束，反转链表即可得到寻路线路。可以看到 A* 最终搜索到了最优路线。&lt;br&gt;
　　A* 算法被提出已经有五十多年了，至今已经有了诸多针对它的优化算法，但是它依然是使用最广泛的寻路算法。这主要归功于它的适用场景十分广泛，它的改进型都或多或少增加了一些场景限制，如果覆盖不到自己的适用场景，那效率再高也是镜花水月。&lt;br&gt;
　　关于 A* 算法有两篇非常好的文章，&lt;a class=&#34;link&#34; href=&#34;https://www.redblobgames.com/pathfinding/a-star/introduction.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to the A* Algorithm&lt;/a&gt; 讲述了 A* 算法的概念。&lt;a class=&#34;link&#34; href=&#34;https://www.redblobgames.com/pathfinding/a-star/implementation.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Implementation of A*&lt;/a&gt; 给出了 A* 算法的几种实现。&lt;/p&gt;
&lt;h3 id=&#34;jps-算法&#34;&gt;JPS 算法&lt;/h3&gt;
&lt;p&gt;　　JPS（Jump Point Search）算法，有时候也翻译成跳点算法。它是 A* 的一种改进方法，实现了效率的大幅度提升。相较于它的老前辈们，JPS 算法的历史非常短，提出至今不过十年左右的时间，但是因为它出色的效率，现在已经基本上成为了 A* 改进型的标杆算法了。&lt;br&gt;
　　但是因为算法特性问题，它的使用场景比较受限，它只支持规则格子地图上的可用和阻挡两种情况，无法处理更复杂的地形，比如地图上某些地块有更高的优先级这种情况，而且它需要两个点之间可以对角线行走。&lt;br&gt;
　　JPS 进行的优化在于，它根据当前地图上的状况，把一些点给排除了，不需要加入到开放集合中。开放集合中的点少了，需要计算的次数自然就少了。而可以加入到开放集合中的点被称为跳点，这也就是跳点算法名字的由来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star.png&#34;
	width=&#34;585&#34;
	height=&#34;397&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_hu42a98a65b65681094b01ac90e439aea5_30047_480x0_resize_box_3.png 480w, https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_a_star_hu42a98a65b65681094b01ac90e439aea5_30047_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;navi_a_star&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;353px&#34;
	
&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_jps.png&#34;
	width=&#34;587&#34;
	height=&#34;403&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_jps_hufb56b9cf37938a4a9840aaec9e74d63f_29287_480x0_resize_box_3.png 480w, https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_jps_hufb56b9cf37938a4a9840aaec9e74d63f_29287_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;navi_jps&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;145&#34;
		data-flex-basis=&#34;349px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　以上两个路径图使用 &lt;a class=&#34;link&#34; href=&#34;https://zerowidth.com/2013/a-visual-explanation-of-jump-point-search.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;A Visual Explanation of Jump Point Search&lt;/a&gt; 页面中的程序实现，图中灰色的点是已经在封闭集合中的，蓝色的点是在开放集合中的。这篇文章不仅有可自定义的寻路小程序，还对 JPS 算法有非常详细的解释，&lt;strong&gt;强烈推荐阅读&lt;/strong&gt;。 &lt;br&gt;
　　在这个例子中可以看到，两个算法找到的路径虽然不一样，但是总开销是一样的，都可以认为是最优解。JPS 处理过的点比 A* 要多，但是绝大部分点因为不符合跳点规则，所以都被忽略了，除开起点和终点，寻路过程中只有六个点被加入到开放列表中处理过，而 A* 在本例中有几十个点都被加入过开放列表，多了大量的运算。&lt;br&gt;
　　在解释 JPS 的步骤之前，需要明确两个它的独有概念，跳点和强制邻居点。虽然说是两个概念，但是其实是两个强关联的概念。如下图是几种强制邻居点的情况，P 是前置点，C 是当前节点，N 是强制邻居点。如果 N 是 C 的邻居，且 N 的邻居中有阻挡点，并且从 P 到 N 的最短路径一定要过 C，则 N 就是 C 的强制邻居点，而 C 就是跳点。如果前置点到当前点是斜向的话，那么当前点两个分量方向上延申的点如果有强制邻居点的话，那么当前点也是跳点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_jps_point.jpg&#34;
	width=&#34;1928&#34;
	height=&#34;2244&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_jps_point_hudab2199855e8f1b4c401bc1f9f55fcef_108539_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_jps_point_hudab2199855e8f1b4c401bc1f9f55fcef_108539_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;navi_jps_point&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;85&#34;
		data-flex-basis=&#34;206px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　JPS 算法的步骤要复杂一些，大概如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先将起点设为当前点，并且将它加入封闭集合中。&lt;/li&gt;
&lt;li&gt;从当前点开始，检查当前点是否有前置点，如果没有前置点的，说明是起始点，起始点的扩散方向为周围全部的 8 个方向。如果不是起始点的，则会首先判断自己有没有强制邻居点，如果有的话，将强制邻居点加入到开放列表中，然后根据前置点和自己的位置判断自己所在的方向，如果自己是在平直方向上，则沿着该方向搜索，如果是在斜角方向上，则先向斜角两个向量方向搜索，然后再沿着斜角搜索。&lt;/li&gt;
&lt;li&gt;在延展搜索的过程中，如果碰到了地图边界或者是阻挡，则停止这个方向上的搜索。对搜索到的每一个点检查它是否有强制邻居点，如果有，则它就是跳点，停止当前的搜索，并且将该点加入到开放列表中。&lt;/li&gt;
&lt;li&gt;检查开放集合，如果为空，则地图搜索已经结束了，跳至步骤 6。&lt;/li&gt;
&lt;li&gt;如果开放集合不为空，则取出其中总开销最小的一个点设为当前点，比较它的位置是否与目标终点一致，如果一致，则搜索结束，否则将它加入到封闭集合中，然后跳回步骤 2。&lt;/li&gt;
&lt;li&gt;当搜索结束时，如果当前点的位置不是目标终点，那么寻路失败。否则从当前点也就是终点开始一直找前置点，这条线路的逆序就是寻路的结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_jps.png&#34;
	width=&#34;587&#34;
	height=&#34;403&#34;
	srcset=&#34;https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_jps_hufb56b9cf37938a4a9840aaec9e74d63f_29287_480x0_resize_box_3.png 480w, https://wmf.im/p/%E6%B5%85%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/navi_jps_hufb56b9cf37938a4a9840aaec9e74d63f_29287_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;navi_jps&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;145&#34;
		data-flex-basis=&#34;349px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　再回过头来复盘一下这个图的寻路过程。首先从起点开始向 8 个方向搜索，搜索右上角到 A 点时，从 A 点向上边和右边扩散，当扩散到 B 点时，发现 B 有强制邻居 C 点，说明 A 是跳点，将 A 的前置点设为起始点并且加入开放列表中，停止继续搜索。&lt;br&gt;
　　从开放列表中拿取一个开销最小的点也就是 A，根据 A 的前置点，得到它的方向是向右上的。向上会碰到边界，向右到达 B 点的时候，可以发现 B 有一个强制邻居点 C，说明 B 是一个跳点，将 B 的前置点设为 A，然后将 B 加入到开放列表中。同时斜角方向发现了跳点 D，将其前置点设为 A 并且加入到开放列表中。&lt;br&gt;
　　从开放列表中拿取一个开销最小的点也就是 B，检查它周围，检查到有一个强制邻居点 C，将 C 的前置点设为 B，B 因为 A 的方向的关系，所以它会沿右方处理，并不会找到新的跳点。&lt;br&gt;
　　从开放列表中拿取一个开销最小的点也就是 C，检查它的周围，发现一个强制邻居点 D，但是 D 已经在开放列表中了，所以不再处理它。C 因为前置点 B 的方向关系，它会向右上搜索。可以找到 E 有一个强制邻居点 F。将 E 的前置点设为 C，并且将它加入开放列表中。&lt;br&gt;
　　从开放列表中拿取一个开销最小的点也就是 E，检查它的周围，发现一个强制邻居点 F，将 F 的前置点设为 E，并且将它加入到开放列表中。E 向右扩展，没有新的发现。&lt;br&gt;
　　从开放列表中拿取一个开销最小的点也就是 F，检查它的周围，发现终点，将终点的前置点设为 F，从终点开始逆序，可以得到 Start → A → B → C → E → F → End 的路线。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;　　寻路算法是一个发展了很久很久的方向，除了上面列出的这三种比较有代表性的算法以外，还有非常非常多的其它算法，不过思路大部分比较类似，都是在前人的基础上做的一些改进。&lt;br&gt;
　　在游戏开发中寻路是个偏前端的问题，除了 SLG 游戏以外，寻路一般都是在前端实现的，后端只会拿前端得到的路径判断一下点的合法性就行了。但是寻路算法的复杂性还并不是这些算法的理解，而是要搞定策划的需求，很多时候高效简洁的实现可能无法满足策划的想法，要在算法的基础上做各种贴近业务的定制化修改。&lt;/p&gt;</description>
        </item>
        <item>
        <title>分析游戏开发中 AOI 的实现思路</title>
        <link>https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</link>
        <pubDate>Sun, 27 Mar 2022 02:18:47 +0800</pubDate>
        
        <guid>https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</guid>
        <description>&lt;p&gt;　　AOI 全称 Area Of Interest, 在游戏开发中用来做角色视野内对象显示同步和状态同步，基本上只要有公共地图的游戏都会涉及到。本篇介绍一些常用的 AOI 实现方法。&lt;/p&gt;
&lt;h2 id=&#34;全局可见&#34;&gt;全局可见&lt;/h2&gt;
&lt;p&gt;　　一个最简单的实现方法是，场景中的所有对象在后端全都互相可见，任何对象的状态修改都会同步给全部的其它对象，在某个客户端上是否要显示某个对象完全依靠客户端来进行选择。&lt;br&gt;
　　这种最大的问题有两个，第一个是性能问题，毕竟每次更新都要广播给全部的对象，如果只有几十个对象还能用，多了就不太行了。第二个就是外挂问题，全部可以见意味着全部发送，这样客户端就有全部的对象数据，外挂可以直接拿到。&lt;br&gt;
　　存储数据也很简单，只保存一个全局的对象表就可以了，对象发生了任何要广播的事件就给剩下全部对象广播。&lt;/p&gt;
&lt;h2 id=&#34;非全局可见&#34;&gt;非全局可见&lt;/h2&gt;
&lt;p&gt;　　在非全局可见的实现中，每个对象要维护一个被关注列表，它是指包含了所有能看到自己的对象的集合，自己的状态改变需要同步给集合中的所有对象。&lt;br&gt;
　　在对象有状态需要更新的情况下，直接广播消息给被关注列表的所有对象即可。比较麻烦的是加入场景和在场景中移动，因为这两种情况下对象需要维护自己的被关注列表，同时也需要更新自己可见的对象的被关注列表。&lt;br&gt;
　　自己可见的对象比较容易查询，因为有自己的视距和坐标，遍历范围内所有位置可以拿到所有自己可见的对象，把自己加入到它们的被关注列表即可。在维护自己的被关注列表时会碰到问题，因为自己并不知道其它对象的视距，所以不能直接遍历周围范围拿到。&lt;br&gt;
　　处理这个问题最简单的方法就是遍历场景上全部的对象，依次计算距离并且与它的视距比较，判断是否可以看见新加入的对象。这种方法只能用在地图比较小的情况下，如果地图很大，那么全局遍历一次是很难接受的。&lt;br&gt;
　　另一种方法就是限制最大视距，因为一般来说不会存在无限视距的对象，所以可以对场景设置一个硬性的视距上限值，任何类型的对象视距都不能超过它。这样在遍历的时候只需要检查最大视距以内的所有对象即可。并且此时可以发现，因为触发修改的对象的视距也不会超过最大视距，所以可以合并两次遍历，即可以通过对最大视距范围内对象的一次遍历完成自己的被关注列表和自己可以看到的对象的被关注列表的更新。&lt;br&gt;
　　根据业务需要也可以考虑增加一个关注列表，即自己可以看到的所有对象的集合。因为在业务中可能需要获取某个对象能看见的全部对象，如果只维护了被关注列表的话，这个获取就会非常麻烦。维护关注列表并不需要额外的计算，只需要在更新自己可以看到的对象的被关注列表时把它加入到自己的关注列表里即可。&lt;/p&gt;
&lt;h2 id=&#34;优化思路&#34;&gt;优化思路&lt;/h2&gt;
&lt;h3 id=&#34;划分格子&#34;&gt;划分格子&lt;/h3&gt;
&lt;p&gt;　　如果以像素为单位遍历地图的话有点太耗费性能了，而且绝大多数业务也不需要这么高的精度，所以一般都会把地图划分成更大的格子来处理。&lt;br&gt;
　　比如坐标格子精度为 64 个像素，那么从 (0, 0) 到 (63, 63) 内的所有对象的相对坐标都是 (0, 0)。每个格子会保存一个当前格子内全部对象以 id 为 key 的哈希结构，查询到格子以后可以方便遍历，离开格子时也可以快速移除。&lt;/p&gt;
&lt;h3 id=&#34;相等视距&#34;&gt;相等视距&lt;/h3&gt;
&lt;p&gt;　　如果游戏中的所有对象的视距都相等的话，那么 AOI 的问题可以被简化很多。&lt;br&gt;
　　当视距全都相等时，可以考虑省略掉为每个对象维护的集合，只对每个坐标维护一个对象列表。因为不管怎么改变，都可以根据对象的位置快速确定有关的坐标点，从而拿到全部的需要处理的对象。&lt;br&gt;
　　如果视距相等并且不需要高精度的情况下，可以结合划分格子的思路，这就是一个常见的实现，“九宫格法” AOI 的思路，它将每个对象的视野限制为以自己为中心格子的九宫格中。&lt;/p&gt;
&lt;h2 id=&#34;十字链表&#34;&gt;十字链表&lt;/h2&gt;
&lt;p&gt;　　AOI 算法中还有一个广泛使用的十字链表法，它本身很有特点，跟上面的思路大相径庭。&lt;br&gt;
　　十字链表法可以用来处理多维的坐标系，在二维坐标系中，会使用两条有序双向链表，一条表示 X 轴，另一条表示 Y 轴。因为链表代表的坐标轴互相垂直像十字架一样，因此得名。&lt;br&gt;
　　它的原理是，如果在 (m, n) 点有一个视距为 20 的对象 O，那么有 x
轴的范围在 (m - 20, m + 20) 的所有点集合 A，y 轴的范围在 (n - 20, n + 20) 的所有点集合 B，A ∩ B 的结果即为 O 的可视范围中所有的点。&lt;br&gt;
　　当对象进入场景时，需要在 x 轴和 y 轴上分别准备三个点，假设对象的视距为 n，则这在 x 轴上的三个点是 x - n，x，x + n，在 y 轴上的三个点为 y - n，y，y + n。两边的两个点是边界点，它们用来判断某个点是否在本点的视距内，中间的点就是坐标点，它用来让别的点的判断它是否在其视距内。同时还需要为对象创建两个临时列表分别用来记录待确认的关注列表和待确认的被关注列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_link.jpg&#34;
	width=&#34;1356&#34;
	height=&#34;572&#34;
	srcset=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_link_hua721b15b866c36e018a1fd13120ec881_32327_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_link_hua721b15b866c36e018a1fd13120ec881_32327_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;corss_link&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;237&#34;
		data-flex-basis=&#34;568px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　假设如图中的 a 和 b 两点，a 的 x 轴坐标为 12，视距是 8，b 的 x 轴坐标为 18，视距为 5。首先 a 先加入到 x 轴中，此时链表为空，直接将 a 加入链表中，然后向前向后分别加入 a+ 和 a- 即可。当 b 加入时，依次会发生以下几个步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;b 跨越 a-，代表了 b 已经进入了 a 的视距中，但是因为还未移动结束，所以会暂时把 a 加入 b 的待确认被关注列表中。&lt;/li&gt;
&lt;li&gt;b 跨越 a，因为都是坐标点，所以不做操作。&lt;/li&gt;
&lt;li&gt;b 到达目标位置停止移动，此时 a 还在 b 的待确认被关注列表中，因为移动已经停止，所以把 a 加入到 b 的被关注列表中即可。&lt;/li&gt;
&lt;li&gt;以 b 的位置为基准点向前查找 b+ 的位置。&lt;/li&gt;
&lt;li&gt;b+ 跨越 a+，因为都是边界点，所以不做操作。&lt;/li&gt;
&lt;li&gt;找到 b+ 的位置，停止查找，创建节点。&lt;/li&gt;
&lt;li&gt;以 b 的位置为基准点向后查找 b- 的位置。&lt;/li&gt;
&lt;li&gt;找到 b- 的位置，停止查找，创建节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　可以看到十字链表法在遍历的时候不是遍历坐标点或者格子的，而是直接遍历对象的，这意味着不需要通过划分格子来优化速度，也就是说可以在相同消耗下保持坐标点级别的精度。同时十字链表法对于视距没有什么要求，不同类型的对象使用不同的视距不会有任何问题。&lt;br&gt;
　　但是它也有一个自己的问题，就是在对象加入的时候，最坏情况下需要遍历每个维度坐标轴上所有的点，如果是二维坐标系则最坏结果为 2 * 3 * N 个节点。&lt;/p&gt;
&lt;h3 id=&#34;快慢指针&#34;&gt;快慢指针&lt;/h3&gt;
&lt;p&gt;　　有一种优化链表查询速度的方法是使用快慢指针。它需要创建两个步长不一样的指针，步长比较长的是快指针，步长比较短的是慢指针。&lt;br&gt;
　　一开始快慢指针都指向表头，遍历的时候会先让快指针走一次，走过之后比较快指针的位置和目标位置，如果还没有到目标位置，则把慢指针的位置指向快指针的位置，并且让快指针继续走。直到快指针的位置超过了目标位置，此时可以确认目标位置就在慢指针和快指针之间，然后移动慢指针查找目标位置即可。&lt;br&gt;
　　快慢指针的优点是实现很简单，而且不需要修改原始的数据结构，缺点是它对查询速度的优化有限，时间复杂度还是 O(n)，且不同的快指针步长也会有不同的优化效果，效率不太稳定。&lt;/p&gt;
&lt;h3 id=&#34;提取索引点&#34;&gt;提取索引点&lt;/h3&gt;
&lt;p&gt;　　优化有序链表的查询还有一个成熟且高效的实现，就是&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Skip_list&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;跳表&lt;/a&gt;。&lt;br&gt;
　　跳表会将链表中的某些点作为索引点提取到上一层组成一个新的有序链表，可以根据需要一共提取出几层快速链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_1st.jpg&#34;
	width=&#34;1356&#34;
	height=&#34;572&#34;
	srcset=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_1st_hub9c04d3ec79d8140e52d2c140872b916_32179_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_1st_hub9c04d3ec79d8140e52d2c140872b916_32179_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;cross_skiplist_axis_1st&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;237&#34;
		data-flex-basis=&#34;568px&#34;
	
&gt;
&lt;img src=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_1st.jpg&#34;
	width=&#34;1764&#34;
	height=&#34;564&#34;
	srcset=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_1st_huee09333fc191cb01cd1d9a6e973b0367_40115_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_1st_huee09333fc191cb01cd1d9a6e973b0367_40115_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;cross_skiplist_1st&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;312&#34;
		data-flex-basis=&#34;750px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　如图是将坐标轴转化为跳表的一个简单例子，在实现的时候可以只选择一些对象坐标点提取为索引点，不提取边界点，因为边界点上没有保存被关注列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_2nd.jpg&#34;
	width=&#34;1356&#34;
	height=&#34;656&#34;
	srcset=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_2nd_huc676e06f1afdab8a9f2eac048bb73117_43911_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_2nd_huc676e06f1afdab8a9f2eac048bb73117_43911_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;cross_skiplist_axis_2nd&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;206&#34;
		data-flex-basis=&#34;496px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　如图尝试为坐标轴增加一个对象 c，它的步骤如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先从最高层级的表头开始查找，找到下一个项为 a 对象。&lt;/li&gt;
&lt;li&gt;比如 c 和 a 坐标，c 大于 a，但是 a 后续已经没有其它项，所以从 a 向下查找，来到下一层。&lt;/li&gt;
&lt;li&gt;在本层中 a 的后续是 b，比较 b 和 c，发现 b 的坐标更大，此时要从 a 继续向下一层找。&lt;/li&gt;
&lt;li&gt;到最下面这一层，首先新增对象要继承当前对象的被关注列表，也包括当前对象本身。也就是 a 要加入到 c 的待确认被关注列表中。&lt;/li&gt;
&lt;li&gt;继续向后，首先 c 会经过 b-，将 b 加入 c 的待确认被关注列表。&lt;/li&gt;
&lt;li&gt;然后跟 b 比较，发现 b 大于 c，所以已经找到了 c 的位置。&lt;/li&gt;
&lt;li&gt;此时 a 和 b 在 c 的待确认被关注列表中，直接将 a 和 b 加入到 c 的被关注列表中即可。&lt;/li&gt;
&lt;li&gt;从 c 的位置开始，向前寻找 c+ 的位置，向后寻找 c- 的位置。&lt;/li&gt;
&lt;li&gt;c- 向后越过了 a，将 c 加入到 a 的被关注列表中。&lt;/li&gt;
&lt;li&gt;c+ 向前越过了 b，将 c 加入到 b 的被关注列表中。&lt;/li&gt;
&lt;li&gt;掷色子将 c 提高层次。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_2nd.jpg&#34;
	width=&#34;2484&#34;
	height=&#34;724&#34;
	srcset=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_2nd_hu29db3ae375bc7823a90d3a693418ca35_65178_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_2nd_hu29db3ae375bc7823a90d3a693418ca35_65178_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;cross_skiplist_2nd&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;343&#34;
		data-flex-basis=&#34;823px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　最终跳表的结构可能如图所示。&lt;br&gt;
　　使用跳表的优点是，速度提升明显，时间复杂度趋近于 O(logn)，远比快慢指针要快很多。缺点也比较明显，首先因为需要额外多层的链表，所以内存占用就更多一些，其次在实现上也会比快慢指针复杂很多，要多写很多代码。&lt;/p&gt;
&lt;h2 id=&#34;独立镜头&#34;&gt;独立镜头&lt;/h2&gt;
&lt;p&gt;　　独立镜头跟上面的方案思路完全不同，它会给每个玩家创建一个镜头对象，这个镜头可以拉近拉远，各种方向移动，移动到哪里就有哪里的视野。&lt;br&gt;
　　镜头一般用在 RTS 和 SLG 这两类游戏中，根据游戏类型的不同，实现也有比较大的区别，基本上可以分为全局广播和视野广播。&lt;/p&gt;
&lt;h3 id=&#34;全局广播&#34;&gt;全局广播&lt;/h3&gt;
&lt;p&gt;　　一般 RTS 游戏都是全局广播的，也就是说只要是在镜头中需要呈现的数据，比如某个对象的血量这种，都会广播给所有的客户端，不管当前改变的数据是否在客户端的镜头下。玩家控制的镜头完全由客户端来实现，客户端拥有完整的数据，根据玩家控制镜头现在的位置显示当前镜头下的对象即可。&lt;br&gt;
　　这样做是因为 RTS 游戏对显示实时性的要求很高，对玩家操作的要求也很高，专业玩家一般会非常频繁地切屏，快速移动镜头，如果每次移动以后再由后端发送镜头中的数据，那就会有一个比较高的显示延迟，这样体验是很差的。&lt;br&gt;
　　因为客户端时刻都要保存并更新整张地图所有对象的位置，所以一般 RTS 的地图会比较小，而且对部队的总数量也会做一些限制，如果不加限制，可能会存在越玩越卡的情况。&lt;/p&gt;
&lt;h3 id=&#34;视野广播&#34;&gt;视野广播&lt;/h3&gt;
&lt;p&gt;　　视野广播一般用在 SLG 这类游戏上。SLG 和 RTS 的区别是，SLG 对操作的要求会低很多，战斗基本都是在拼数值，所以对实时性的要求也降低了不少。而且 SLG 的地图一般会比 RTS 大很多，地图上的单位也会多很多，这也要求了 SLG 游戏不能做全局广播。&lt;br&gt;
　　一般的实现会把地图分成若干格子，后端根据镜头的位置和视野，会维护一张记录了对每个格子可见的镜头表，镜头发生移动或者是有玩家进入退出游戏，就会改变这张表，实时更新。&lt;br&gt;
　　当一个单位的某个属性发生了变化，如果该属性是需要在镜头中呈现的，那么会将数据变更发送给镜头服务，镜头服务根据单位的坐标拿到它所在的格子，通过格子拿到所有可以看到该格子的镜头，把数据更新给持有控制镜头的玩家客户端。&lt;br&gt;
　　当镜头移动时，客户端可以等镜头相对静止以后再给后端发送镜头位置变更的消息，这样可以减少玩家移动镜头时的消耗。&lt;/p&gt;
&lt;h3 id=&#34;战争迷雾&#34;&gt;战争迷雾&lt;/h3&gt;
&lt;p&gt;　　RTS 或者是 SLG 这类游戏大部分都有战争迷雾，一般 RTS 游戏的迷雾都是在客户端实现的，不管有没有迷雾，后端都会将数据变更都会同步给全部的客户端。之所以这么实现，主要还是因为 RTS 游戏对实时性的要求比较高，如果破迷雾以后再发送数据过去，可能二三百毫秒的延迟，一场战斗的走向就完全变了。因为数据全发送，所以必然会有全图外挂，甚至一些处理的比较粗糙的游戏可以直接听到迷雾下面的声音，比如红警就可以听采矿车声音判断迷雾下面的对手是盟军还是苏俄。脱胎于 RTS 游戏的 MOBA 游戏一般也是一样的设计。&lt;br&gt;
　　SLG 采用视野广播，就完全可以做到只广播镜头可见的数据，迷雾下的数据全部不发送。这样可以完全避免全图外挂的可能性。同时 SLG 也可以接受一定的显示延迟。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>

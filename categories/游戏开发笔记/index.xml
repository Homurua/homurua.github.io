<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>游戏开发笔记 on 放学后茶会</title>
        <link>https://wmf.im/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</link>
        <description>Recent content in 游戏开发笔记 on 放学后茶会</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 08 Apr 2022 22:38:27 +0800</lastBuildDate><atom:link href="https://wmf.im/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>游戏开发中的存储系统设计</title>
        <link>https://wmf.im/p/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</link>
        <pubDate>Fri, 08 Apr 2022 22:38:27 +0800</pubDate>
        
        <guid>https://wmf.im/p/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</guid>
        <description>&lt;p&gt;　　游戏开发中如何进行高效稳定的数据存取，一直是非常重要的问题。本篇中会尝试分析一下常见的存储方案。&lt;/p&gt;
&lt;h2 id=&#34;数据库选择&#34;&gt;数据库选择&lt;/h2&gt;
&lt;p&gt;　　如果是早几年的话，这基本上是个不需要讨论的问题，因为 MySQL 是当时绝对的主流选择，但是最近几年这种情况发生了一些变化，让数据库选择有了更多的方案。&lt;/p&gt;
&lt;h3 id=&#34;直接读写文件&#34;&gt;直接读写文件&lt;/h3&gt;
&lt;p&gt;　　使用直接读写文件这种方式来保存游戏内数据的公司应该很少很少了，可能只有一些还抱着祖传代码不想撒手的公司还在用。&lt;br&gt;
　　不过大部分公司在保存日志或者是战斗录像这种单个文件内容比较大，并且不会修改的数据的时候都还会使用这种方法，尤其是对时间久的一些日志，基本上不会查询，只做留档使用了。&lt;br&gt;
　　采用这种方式的实现，一般是将每种类型数据中每一个 key 作为文件名，数据作为文件内容来存储。每种数据可以使用一到多个文件夹来管理。创建和更新数据的时候一般使用某种序列化方式将内存中需要保存的数据打包，然后写入到适当的目录下。读取数据的时候通过数据类型和 key 找到对应目录下的文件，通过文件 I/O 将其读入内存中，再反序列化得到数据。&lt;/p&gt;
&lt;h3 id=&#34;mysql&#34;&gt;MySQL&lt;/h3&gt;
&lt;p&gt;　　凭借开源且免费的特点，MySQL 逐渐变成了关系型数据库的代表。在 NoSQL 数据库兴起之前，MySQL 基本上是有统治级别的使用率。&lt;br&gt;
　　MySQL 虽强，但是这几年它增加了一批非常有竞争力的对手，也令他的统治地位有点一些动摇。不过 MySQL 目前也依然活跃在相当大比例的游戏公司中，毕竟大部分公司对 MySQL 都有丰富的使用经验，很多坑也都踩过填过了，选用一个成熟可靠的数据库也是很正常的事情。&lt;br&gt;
　　使用 MySQL 存储数据的话，有两种用法，第一是完全按照关系型数据库那种每张表分字段的方法。还有一种是当作 key - value 数据库来用，每张表只有两个字段，key 和 value，会把本张表中要保存的所有字段都使用一种方式序列化成一个值，存入一个 blob 类型的 value 中，不过这种方法在数据更新的时候没办法单独更新字段，只能再次将 value 完整序列化替换掉旧值。&lt;/p&gt;
&lt;h3 id=&#34;redis&#34;&gt;Redis&lt;/h3&gt;
&lt;p&gt;　　Redis 应该是后起之秀里面攻势最猛的了，因为它的性能优势，使它深受对实时性要求很高的游戏行业青睐。&lt;br&gt;
　　它同样开源免费，而且因为全部数据都在内存中，所以它无论是读取还是写入，都对传统的磁盘数据库有碾压的表现。当然缺点也很明显，毕竟相同单位大小的内存比硬盘可是贵的多了，而且系统和硬件支持内存的容量上限也远远小于硬盘。同时数据在内存里也并不安全，如果需要开持久化的话，它的性能会有一些下降。&lt;br&gt;
　　在 Redis 中保存数据一般采用 &amp;ldquo;数据类型 + uid&amp;rdquo; 作为 key，每个数据是一个哈希表，其中保存了它的所有字段。同时 Redis 也可以非常方便的保存一些全局数据。&lt;/p&gt;
&lt;h3 id=&#34;mongodb&#34;&gt;MongoDB&lt;/h3&gt;
&lt;p&gt;　　如果说 Redis 是 NoSQL 数据库中发展最好的内存数据库，那么 MongoDB 就是 NoSQL 数据库中发展最好的磁盘数据库了，在游戏公司中使用的更多。&lt;br&gt;
　　模式自由（Schema-free）的数据库对游戏公司的业务是非常合适的。不再需要做业务的时候经常改表的字段了。最重要的是，游戏公司的业务基本上是不需要使用关系型数据库提供的复杂特性，也不需要使用 SQL 进行复杂的查询，这使得关系型数据库的优势难以发挥。&lt;br&gt;
　　不过它也有很多为人诟病的地方，比如相对一些成熟的老牌数据库来说稳定性，性能，内存占用等方面都有一些劣势，但是这些年随着版本不断迭代，各方面进步都很大，已经长期霸占 &lt;a class=&#34;link&#34; href=&#34;https://db-engines.com/en/ranking&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DB Engine&lt;/a&gt; 的第五名了。&lt;br&gt;
　　MongdoDB 也是 key - value 数据库，不过它在外层有一个集合的概念，基本上相当于关系型数据库中的表了，使用的时候将不同功能的数据放在不同的集合中即可。&lt;/p&gt;
&lt;h2 id=&#34;存储方案&#34;&gt;存储方案&lt;/h2&gt;
&lt;p&gt;　　一个完整开发的较大规模的游戏项目，基本上不会只是用一种存储数据的方式。因为游戏中对各种数据的使用和保存方式都有很大区别，这导致了很难有一种完全的方法可以搞定所有数据的存储。所以一般都是采用多种方式混合的数据存储方案。&lt;/p&gt;
&lt;h3 id=&#34;加载数据&#34;&gt;加载数据&lt;/h3&gt;
&lt;p&gt;　　数据被加载大概有两种处理方式，启服时全量加载不释放，按需加载使用完释放。&lt;br&gt;
　　适合全量加载不释放的数据必须规模不是太大，且要使用非常频繁，这样才有常驻内存中的价值。一般都是用来保存进程的全局数据。&lt;br&gt;
　　按需加载使用完释放，一般用来保存跟个体有关的数据，这部分数据当个体没有操作的时候，大部分情况下是完全用不到的。这种形式可以再加上一层缓存层来加快热点数据加载，这个缓存层如果需求比较简单可以自己实现，如果需要一些高级功能，可以使用 Redis 来做。&lt;/p&gt;
&lt;h3 id=&#34;写入数据&#34;&gt;写入数据&lt;/h3&gt;
&lt;p&gt;　　写入数据的方式大概有四种，每次修改直接落地，定时全量落地队列，定时脏数据落地队列，数据离线全量落地。&lt;br&gt;
　　每次修改直接落地的代价比较大，要严格控制这类操作的使用范围，一般只有高优先级的操作引起的数据变更会考虑使用每次修改直接落地的操作。&lt;br&gt;
　　定时全量落地队列，是指在某个对象的数据发生变更以后，将其加入到一个变更对象列表中，然后每隔一段时间，将列表中对象的所有数据进行一次落地。&lt;br&gt;
　　定时脏数据落地队列，是指在对象的某个数据发生变更以后，将对象和修改的字段加入到变更对象列表中，然后每隔一段时间，将列表中的变更对象被修改字段的数据落地。&lt;br&gt;
　　数据离线全量落地，是某个对象要从内存中删除这种情况，在删除之前会对这个对象进行一次全量的保存，一般作为别的方案的保底。&lt;/p&gt;
&lt;h2 id=&#34;数据分类&#34;&gt;数据分类&lt;/h2&gt;
&lt;p&gt;　　选择存储方案需要根据实际需求来考量，数据的不同使用场景和范围，都对应了不同的存储方案。&lt;/p&gt;
&lt;h3 id=&#34;玩家数据&#34;&gt;玩家数据&lt;/h3&gt;
&lt;p&gt;　　游戏中玩家数据的总量是很大的，即使是日活月活都不太高的游戏，它的注册用户可能也是很惊人的一个量。这就导致了玩家数据在起服时全部加载到内存中变成不现实的事情。&lt;br&gt;
　　玩家的数据大概有两类组成，第一类是别的系统可能会在玩家离线的时候读取的部分，可能有的是玩家的名字，uid，签名，等级，所属工会等基本信息。另一类是别的系统不会读取，只有玩家自己登录以后才会使用的数据，比如背包中的物品数量，经验值，体力值这些。在开发中有时也会称第一类为对外数据，第二类为对内数据。&lt;br&gt;
　　对内数据和对外数据因为使用场景不同，一般会分表来保存，不放在一起，方便读取，加载策略也有一些区别。对内数据只有在玩家登录的时候才会从硬盘上加载进游戏服的内存中，玩家下线以后就可以释放掉这部分内存了，一般不会缓存这部分数据，而是可能会做一个延迟删除对象的设定，来应对玩家可能的立马再次上线。对外数据经常要被其它系统读取，比如好友之类的系统，一些高等级玩家的数据可能会经常被访问，所以一般会使用带缓存的按需加载。&lt;br&gt;
　　玩家数据的变更是非常频繁的，一个在线玩家即使是完全不做任何操作，可能也会有一些定时器会修改他的数据。如果每次的修改都落地到硬盘显然是不现实的。一般采用定时脏数据落地队列的方案进行数据更新，有时也会再加上数据离线全量落地作为保底。&lt;/p&gt;
&lt;h3 id=&#34;全局数据&#34;&gt;全局数据&lt;/h3&gt;
&lt;p&gt;　　游戏中有一些全局数据，这些数据一般单个服务器只有一份，数据量不会太大，但是访问频率很高。像是当前开放的活动中的数据，以及一些功能的全服状态。&lt;br&gt;
　　这种全局数据直接在启动时全部加载进内存即可，整个功能的开放周期中都存在于内存里，数据保存方式可以按需选择，一般也用定时脏数据落地队列即可。&lt;/p&gt;
&lt;h3 id=&#34;功能数据&#34;&gt;功能数据&lt;/h3&gt;
&lt;p&gt;　　很多功能性系统的数据是会脱离玩家数据单独保存的，比如像公会，聊天这种，这部分数据相对比较独立，一般只有自己系统会用。&lt;br&gt;
　　这些系统的总数据量可能会非常大，尤其是像需要保存全部记录的聊天系统，会越来越大。这些数据如果也是启动时全部加载是不太现实的，一般使用按需加载使用完释放，并且要加上缓存系统，因为这些数据会有明显的优先级，比如高排名的公会信息可能经常被查看，同样在一个会话中最新的聊天记录也会被经常查看。&lt;/p&gt;
&lt;h3 id=&#34;日志数据&#34;&gt;日志数据&lt;/h3&gt;
&lt;p&gt;　　日志类数据不仅包含了日志，还有类似战斗录像这种数据。如果说其它数据只是比较大的话，那日志类数据就真的是巨大了，远超其它数据很多个数量级，这就导致了它需要一些特殊的手段来处理。&lt;br&gt;
　　一般处理日志类数据有两种方法，存数据库，或者是把每小时的日志存进一个独立文件里。存数据库可以方便直接进行查询，不过用这种方法的公司比较少，因为日志数据实在是太多了。存成文件的好处是，可以直接通过目录查看，清晰直观，也不需要生产环境的数据库权限就可以查看这些文件，如果需要进行分析，可以使用一些日志分析工具进行后期分析。&lt;br&gt;
　　有一些项目要求只要保存一定时间以内的日志即可，比如 30 天，这种就比较简单，每天把最后一天的日志删除即可，总量一直在一个可以接受的范围内。但是有一些项目是需要永久保存日志的，这种需求就需要将非临近日期的日志进行二次处理，一般是将其打包压缩，然后可以选择一种更加便宜的存储介质来保存，比如说磁带。&lt;/p&gt;</description>
        </item>
        <item>
        <title>分析游戏开发中 AOI 的实现思路</title>
        <link>https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</link>
        <pubDate>Sun, 27 Mar 2022 02:18:47 +0800</pubDate>
        
        <guid>https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</guid>
        <description>&lt;p&gt;　　AOI 全称 Area Of Interest, 在游戏开发中用来做角色视野内对象显示同步和状态同步，基本上只要有公共地图的游戏都会涉及到。本篇介绍一些常用的 AOI 实现方法。&lt;/p&gt;
&lt;h2 id=&#34;全局可见&#34;&gt;全局可见&lt;/h2&gt;
&lt;p&gt;　　一个最简单的实现方法是，场景中的所有对象在后端全都互相可见，任何对象的状态修改都会同步给全部的其它对象，在某个客户端上是否要显示某个对象完全依靠客户端来进行选择。&lt;br&gt;
　　这种最大的问题有两个，第一个是性能问题，毕竟每次更新都要广播给全部的对象，如果只有几十个对象还能用，多了就不太行了。第二个就是外挂问题，全部可以见意味着全部发送，这样客户端就有全部的对象数据，外挂可以直接拿到。&lt;br&gt;
　　存储数据也很简单，只保存一个全局的对象表就可以了，对象发生了任何要广播的事件就给剩下全部对象广播。&lt;/p&gt;
&lt;h2 id=&#34;非全局可见&#34;&gt;非全局可见&lt;/h2&gt;
&lt;p&gt;　　在非全局可见的实现中，每个对象要维护一个被关注列表，它是指包含了所有能看到自己的对象的集合，自己的状态改变需要同步给集合中的所有对象。&lt;br&gt;
　　在对象有状态需要更新的情况下，直接广播消息给被关注列表的所有对象即可。比较麻烦的是加入场景和在场景中移动，因为这两种情况下对象需要维护自己的被关注列表，同时也需要更新自己可见的对象的被关注列表。&lt;br&gt;
　　自己可见的对象比较容易查询，因为有自己的视距和坐标，遍历范围内所有位置可以拿到所有自己可见的对象，把自己加入到它们的被关注列表即可。在维护自己的被关注列表时会碰到问题，因为自己并不知道其它对象的视距，所以不能直接遍历周围范围拿到。&lt;br&gt;
　　处理这个问题最简单的方法就是遍历场景上全部的对象，依次计算距离并且与它的视距比较，判断是否可以看见新加入的对象。这种方法只能用在地图比较小的情况下，如果地图很大，那么全局遍历一次是很难接受的。&lt;br&gt;
　　另一种方法就是限制最大视距，因为一般来说不会存在无限视距的对象，所以可以对场景设置一个硬性的视距上限值，任何类型的对象视距都不能超过它。这样在遍历的时候只需要检查最大视距以内的所有对象即可。并且此时可以发现，因为触发修改的对象的视距也不会超过最大视距，所以可以合并两次遍历，即可以通过对最大视距范围内对象的一次遍历完成自己的被关注列表和自己可以看到的对象的被关注列表的更新。&lt;br&gt;
　　根据业务需要也可以考虑增加一个关注列表，即自己可以看到的所有对象的集合。因为在业务中可能需要获取某个对象能看见的全部对象，如果只维护了被关注列表的话，这个获取就会非常麻烦。维护关注列表并不需要额外的计算，只需要在更新自己可以看到的对象的被关注列表时把它加入到自己的关注列表里即可。&lt;/p&gt;
&lt;h2 id=&#34;优化思路&#34;&gt;优化思路&lt;/h2&gt;
&lt;h3 id=&#34;划分格子&#34;&gt;划分格子&lt;/h3&gt;
&lt;p&gt;　　如果以像素为单位遍历地图的话有点太耗费性能了，而且绝大多数业务也不需要这么高的精度，所以一般都会把地图划分成更大的格子来处理。&lt;br&gt;
　　比如坐标格子精度为 64 个像素，那么从 (0, 0) 到 (63, 63) 内的所有对象的相对坐标都是 (0, 0)。每个格子会保存一个当前格子内全部对象以 id 为 key 的哈希结构，查询到格子以后可以方便遍历，离开格子时也可以快速移除。&lt;/p&gt;
&lt;h3 id=&#34;相等视距&#34;&gt;相等视距&lt;/h3&gt;
&lt;p&gt;　　如果游戏中的所有对象的视距都相等的话，那么 AOI 的问题可以被简化很多。&lt;br&gt;
　　当视距全都相等时，可以考虑省略掉为每个对象维护的集合，只对每个坐标维护一个对象列表。因为不管怎么改变，都可以根据对象的位置快速确定有关的坐标点，从而拿到全部的需要处理的对象。&lt;br&gt;
　　如果视距相等并且不需要高精度的情况下，可以结合划分格子的思路，这就是一个常见的实现，“九宫格法” AOI 的思路，它将每个对象的视野限制为以自己为中心格子的九宫格中。&lt;/p&gt;
&lt;h2 id=&#34;十字链表&#34;&gt;十字链表&lt;/h2&gt;
&lt;p&gt;　　AOI 算法中还有一个广泛使用的十字链表法，它本身很有特点，跟上面的思路大相径庭。&lt;br&gt;
　　十字链表法可以用来处理多维的坐标系，在二维坐标系中，会使用两条有序双向链表，一条表示 X 轴，另一条表示 Y 轴。因为链表代表的坐标轴互相垂直像十字架一样，因此得名。&lt;br&gt;
　　它的原理是，如果在 (m, n) 点有一个视距为 20 的对象 O，那么有 x
轴的范围在 (m - 20, m + 20) 的所有点集合 A，y 轴的范围在 (n - 20, n + 20) 的所有点集合 B，A ∩ B 的结果即为 O 的可视范围中所有的点。&lt;br&gt;
　　当对象进入场景时，需要在 x 轴和 y 轴上分别准备三个点，假设对象的视距为 n，则这在 x 轴上的三个点是 x - n，x，x + n，在 y 轴上的三个点为 y - n，y，y + n。两边的两个点是边界点，它们用来判断某个点是否在本点的视距内，中间的点就是坐标点，它用来让别的点的判断它是否在其视距内。同时还需要为对象创建两个临时列表分别用来记录待确认的关注列表和待确认的被关注列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_link.jpg&#34;
	width=&#34;1356&#34;
	height=&#34;572&#34;
	srcset=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_link_hua721b15b866c36e018a1fd13120ec881_32327_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_link_hua721b15b866c36e018a1fd13120ec881_32327_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;corss_link&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;237&#34;
		data-flex-basis=&#34;568px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　假设如图中的 a 和 b 两点，a 的 x 轴坐标为 12，视距是 8，b 的 x 轴坐标为 18，视距为 5。首先 a 先加入到 x 轴中，此时链表为空，直接将 a 加入链表中，然后向前向后分别加入 a+ 和 a- 即可。当 b 加入时，依次会发生以下几个步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;b 跨越 a-，代表了 b 已经进入了 a 的视距中，但是因为还未移动结束，所以会暂时把 a 加入 b 的待确认被关注列表中。&lt;/li&gt;
&lt;li&gt;b 跨越 a，因为都是坐标点，所以不做操作。&lt;/li&gt;
&lt;li&gt;b 到达目标位置停止移动，此时 a 还在 b 的待确认被关注列表中，因为移动已经停止，所以把 a 加入到 b 的被关注列表中即可。&lt;/li&gt;
&lt;li&gt;以 b 的位置为基准点向前查找 b+ 的位置。&lt;/li&gt;
&lt;li&gt;b+ 跨越 a+，因为都是边界点，所以不做操作。&lt;/li&gt;
&lt;li&gt;找到 b+ 的位置，停止查找，创建节点。&lt;/li&gt;
&lt;li&gt;以 b 的位置为基准点向后查找 b- 的位置。&lt;/li&gt;
&lt;li&gt;找到 b- 的位置，停止查找，创建节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　可以看到十字链表法在遍历的时候不是遍历坐标点或者格子的，而是直接遍历对象的，这意味着不需要通过划分格子来优化速度，也就是说可以在相同消耗下保持坐标点级别的精度。同时十字链表法对于视距没有什么要求，不同类型的对象使用不同的视距不会有任何问题。&lt;br&gt;
　　但是它也有一个自己的问题，就是在对象加入的时候，最坏情况下需要遍历每个维度坐标轴上所有的点，如果是二维坐标系则最坏结果为 2 * 3 * N 个节点。&lt;/p&gt;
&lt;h3 id=&#34;快慢指针&#34;&gt;快慢指针&lt;/h3&gt;
&lt;p&gt;　　有一种优化链表查询速度的方法是使用快慢指针。它需要创建两个步长不一样的指针，步长比较长的是快指针，步长比较短的是慢指针。&lt;br&gt;
　　一开始快慢指针都指向表头，遍历的时候会先让快指针走一次，走过之后比较快指针的位置和目标位置，如果还没有到目标位置，则把慢指针的位置指向快指针的位置，并且让快指针继续走。直到快指针的位置超过了目标位置，此时可以确认目标位置就在慢指针和快指针之间，然后移动慢指针查找目标位置即可。&lt;br&gt;
　　快慢指针的优点是实现很简单，而且不需要修改原始的数据结构，缺点是它对查询速度的优化有限，时间复杂度还是 O(n)，且不同的快指针步长也会有不同的优化效果，效率不太稳定。&lt;/p&gt;
&lt;h3 id=&#34;提取索引点&#34;&gt;提取索引点&lt;/h3&gt;
&lt;p&gt;　　优化有序链表的查询还有一个成熟且高效的实现，就是&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Skip_list&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;跳表&lt;/a&gt;。&lt;br&gt;
　　跳表会将链表中的某些点作为索引点提取到上一层组成一个新的有序链表，可以根据需要一共提取出几层快速链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_1st.jpg&#34;
	width=&#34;1356&#34;
	height=&#34;572&#34;
	srcset=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_1st_hub9c04d3ec79d8140e52d2c140872b916_32179_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_1st_hub9c04d3ec79d8140e52d2c140872b916_32179_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;cross_skiplist_axis_1st&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;237&#34;
		data-flex-basis=&#34;568px&#34;
	
&gt;
&lt;img src=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_1st.jpg&#34;
	width=&#34;1764&#34;
	height=&#34;564&#34;
	srcset=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_1st_huee09333fc191cb01cd1d9a6e973b0367_40115_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_1st_huee09333fc191cb01cd1d9a6e973b0367_40115_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;cross_skiplist_1st&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;312&#34;
		data-flex-basis=&#34;750px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　如图是将坐标轴转化为跳表的一个简单例子，在实现的时候可以只选择一些对象坐标点提取为索引点，不提取边界点，因为边界点上没有保存被关注列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_2nd.jpg&#34;
	width=&#34;1356&#34;
	height=&#34;656&#34;
	srcset=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_2nd_huc676e06f1afdab8a9f2eac048bb73117_43911_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_axis_2nd_huc676e06f1afdab8a9f2eac048bb73117_43911_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;cross_skiplist_axis_2nd&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;206&#34;
		data-flex-basis=&#34;496px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　如图尝试为坐标轴增加一个对象 c，它的步骤如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先从最高层级的表头开始查找，找到下一个项为 a 对象。&lt;/li&gt;
&lt;li&gt;比如 c 和 a 坐标，c 大于 a，但是 a 后续已经没有其它项，所以从 a 向下查找，来到下一层。&lt;/li&gt;
&lt;li&gt;在本层中 a 的后续是 b，比较 b 和 c，发现 b 的坐标更大，此时要从 a 继续向下一层找。&lt;/li&gt;
&lt;li&gt;到最下面这一层，首先新增对象要继承当前对象的被关注列表，也包括当前对象本身。也就是 a 要加入到 c 的待确认被关注列表中。&lt;/li&gt;
&lt;li&gt;继续向后，首先 c 会经过 b-，将 b 加入 c 的待确认被关注列表。&lt;/li&gt;
&lt;li&gt;然后跟 b 比较，发现 b 大于 c，所以已经找到了 c 的位置。&lt;/li&gt;
&lt;li&gt;此时 a 和 b 在 c 的待确认被关注列表中，直接将 a 和 b 加入到 c 的被关注列表中即可。&lt;/li&gt;
&lt;li&gt;从 c 的位置开始，向前寻找 c+ 的位置，向后寻找 c- 的位置。&lt;/li&gt;
&lt;li&gt;c- 向后越过了 a，将 c 加入到 a 的被关注列表中。&lt;/li&gt;
&lt;li&gt;c+ 向前越过了 b，将 c 加入到 b 的被关注列表中。&lt;/li&gt;
&lt;li&gt;掷色子将 c 提高层次。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_2nd.jpg&#34;
	width=&#34;2484&#34;
	height=&#34;724&#34;
	srcset=&#34;https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_2nd_hu29db3ae375bc7823a90d3a693418ca35_65178_480x0_resize_q75_box.jpg 480w, https://wmf.im/p/%E5%88%86%E6%9E%90%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD-aoi-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/cross_skiplist_2nd_hu29db3ae375bc7823a90d3a693418ca35_65178_1024x0_resize_q75_box.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;cross_skiplist_2nd&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;343&#34;
		data-flex-basis=&#34;823px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;　　最终跳表的结构可能如图所示。&lt;br&gt;
　　使用跳表的优点是，速度提升明显，时间复杂度趋近于 O(logn)，远比快慢指针要快很多。缺点也比较明显，首先因为需要额外多层的链表，所以内存占用就更多一些，其次在实现上也会比快慢指针复杂很多，要多写很多代码。&lt;/p&gt;
&lt;h2 id=&#34;独立镜头&#34;&gt;独立镜头&lt;/h2&gt;
&lt;p&gt;　　独立镜头跟上面的方案思路完全不同，它会给每个玩家创建一个镜头对象，这个镜头可以拉近拉远，各种方向移动，移动到哪里就有哪里的视野。&lt;br&gt;
　　镜头一般用在 RTS 和 SLG 这两类游戏中，根据游戏类型的不同，实现也有比较大的区别，基本上可以分为全局广播和视野广播。&lt;/p&gt;
&lt;h3 id=&#34;全局广播&#34;&gt;全局广播&lt;/h3&gt;
&lt;p&gt;　　一般 RTS 游戏都是全局广播的，也就是说只要是在镜头中需要呈现的数据，比如某个对象的血量这种，都会广播给所有的客户端，不管当前改变的数据是否在客户端的镜头下。玩家控制的镜头完全由客户端来实现，客户端拥有完整的数据，根据玩家控制镜头现在的位置显示当前镜头下的对象即可。&lt;br&gt;
　　这样做是因为 RTS 游戏对显示实时性的要求很高，对玩家操作的要求也很高，专业玩家一般会非常频繁地切屏，快速移动镜头，如果每次移动以后再由后端发送镜头中的数据，那就会有一个比较高的显示延迟，这样体验是很差的。&lt;br&gt;
　　因为客户端时刻都要保存并更新整张地图所有对象的位置，所以一般 RTS 的地图会比较小，而且对部队的总数量也会做一些限制，如果不加限制，可能会存在越玩越卡的情况。&lt;/p&gt;
&lt;h3 id=&#34;视野广播&#34;&gt;视野广播&lt;/h3&gt;
&lt;p&gt;　　视野广播一般用在 SLG 这类游戏上。SLG 和 RTS 的区别是，SLG 对操作的要求会低很多，战斗基本都是在拼数值，所以对实时性的要求也降低了不少。而且 SLG 的地图一般会比 RTS 大很多，地图上的单位也会多很多，这也要求了 SLG 游戏不能做全局广播。&lt;br&gt;
　　一般的实现会把地图分成若干格子，后端根据镜头的位置和视野，会维护一张记录了对每个格子可见的镜头表，镜头发生移动或者是有玩家进入退出游戏，就会改变这张表，实时更新。&lt;br&gt;
　　当一个单位的某个属性发生了变化，如果该属性是需要在镜头中呈现的，那么会将数据变更发送给镜头服务，镜头服务根据单位的坐标拿到它所在的格子，通过格子拿到所有可以看到该格子的镜头，把数据更新给持有控制镜头的玩家客户端。&lt;br&gt;
　　当镜头移动时，客户端可以等镜头相对静止以后再给后端发送镜头位置变更的消息，这样可以减少玩家移动镜头时的消耗。&lt;/p&gt;
&lt;h3 id=&#34;战争迷雾&#34;&gt;战争迷雾&lt;/h3&gt;
&lt;p&gt;　　RTS 或者是 SLG 这类游戏大部分都有战争迷雾，一般 RTS 游戏的迷雾都是在客户端实现的，不管有没有迷雾，后端都会将数据变更都会同步给全部的客户端。之所以这么实现，主要还是因为 RTS 游戏对实时性的要求比较高，如果破迷雾以后再发送数据过去，可能二三百毫秒的延迟，一场战斗的走向就完全变了。因为数据全发送，所以必然会有全图外挂，甚至一些处理的比较粗糙的游戏可以直接听到迷雾下面的声音，比如红警就可以听采矿车声音判断迷雾下面的对手是盟军还是苏俄。脱胎于 RTS 游戏的 MOBA 游戏一般也是一样的设计。&lt;br&gt;
　　SLG 采用视野广播，就完全可以做到只广播镜头可见的数据，迷雾下的数据全部不发送。这样可以完全避免全图外挂的可能性。同时 SLG 也可以接受一定的显示延迟。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>

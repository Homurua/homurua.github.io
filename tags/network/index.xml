<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>network on 放学后茶会</title>
        <link>https://wmf.im/tags/network/</link>
        <description>Recent content in network on 放学后茶会</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 28 Mar 2022 02:18:47 +0800</lastBuildDate><atom:link href="https://wmf.im/tags/network/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>为什么需要 RUDP 协议</title>
        <link>https://wmf.im/p/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-rudp-%E5%8D%8F%E8%AE%AE/</link>
        <pubDate>Mon, 28 Mar 2022 02:18:47 +0800</pubDate>
        
        <guid>https://wmf.im/p/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-rudp-%E5%8D%8F%E8%AE%AE/</guid>
        <description>&lt;p&gt;　　RUDP 是 Reliable UDP 的简称，指可靠 UDP 协议。它通过一些额外的操作，为 UDP 协议提供了可靠性。本篇会来尝试比较一下 RUDP 和 TCP 的区别。&lt;/p&gt;
&lt;h2 id=&#34;引子&#34;&gt;引子&lt;/h2&gt;
&lt;p&gt;　　UDP 和 TCP 是传输层最常用的两个协议。UDP 是个不可靠的协议，它不保证数据交付，而 TCP 是可靠的，它可以保证接收方接收的字节流与发送方发送的字节流完全相同。&lt;br&gt;
　　那么就有了一个问题，既然已经有 TCP 提供可靠服务了，直接用不可以吗？为什么还要魔改 UDP 让它来提供可靠服务呢？&lt;br&gt;
　　要回答这个问题，首先要了解一下 TCP 的弱点是什么。&lt;/p&gt;
&lt;h2 id=&#34;tcp-的弱点&#34;&gt;TCP 的弱点&lt;/h2&gt;
&lt;p&gt;　　TCP 之所以可以保证可靠，是因为它使用了包括数据校验和，为报文段增加序号，增加接收方反馈，超时重传，快速重传，在双端增加缓冲区等机制。&lt;br&gt;
　　当网络畅通无阻时，这些机制都可以非常有效的运行，也就是说如果网络环境良好时，没必要使用 RUDP 了，直接使用 TCP 就是最好的选择。&lt;br&gt;
　　但是实际中的网络环境千差万别，尤其是现在移动互联网盛行，用户可能是在地铁，电梯等信号不太强的地方使用 4G 等方式上网的。这时候如果继续使用 TCP 的话，在一些对网络延迟要求比较高的场景中体验可能就会很差。&lt;br&gt;
　　来看一些 TCP 的各种机制存在的问题。&lt;/p&gt;
&lt;h3 id=&#34;三次握手&#34;&gt;三次握手&lt;/h3&gt;
&lt;p&gt;　　众所周知，TCP 在建立连接的时候需要三次握手才行，三次握手一共需要 1.5 RTT 才能完成。如果是在 HTTPS 上的话，则三次握手以后还要再次进行 TLS 握手，又需要 1.5 RTT 才行。&lt;br&gt;
　　虽然大部分情况下握手带来的消耗并不大，但是如果想要更快速的建立起连接，那这就是一个可以优化的地方。&lt;br&gt;
　　以 Web 开发已经大量使用的 QUIC 协议来说，它可以合并连接握手和加密握手，最终在 1.5 RTT 内实现连接建立，甚至可以通过对服务器的缓存，实现 0 RTT 建立连接。&lt;/p&gt;
&lt;h3 id=&#34;四次挥手&#34;&gt;四次挥手&lt;/h3&gt;
&lt;p&gt;　　因为 TCP 全双工的特点，且报文段都需要 ACK 来确认。所以 TCP 的断开连接比握手更麻烦一点，要 A 先发送断开报文，B 确认断开报文，B 再发送断开报文，A 确认断开报文，才能完成整条连接的关闭。&lt;br&gt;
　　因为报文又涉及到重传之类的问题，所以还需要设计出一个 TIME_WAIT 状态，等待 2 MSL 来确认对方收到了自己对它的断开报文的确认。&lt;br&gt;
　　QUIC 对这个过程也进行了不小的简化，比如把关闭改为了单工的，一方发起关闭即代表了整条连接的关闭，同时也简化了连接的状态机，不再需要 TIME_WAIT 状态。&lt;/p&gt;
&lt;h3 id=&#34;rto-倍率&#34;&gt;RTO 倍率&lt;/h3&gt;
&lt;p&gt;　　TCP 会为拥有最小还未被确认序号（SendBase）的报文段设置一个重传定时器，如果超时了，会将它重传，并且会再次为它设置定时器。如果收到了确认报文，则会取消当前的定时器，为下一个待确认报文创建新的定时器。&lt;br&gt;
　　重传超时的时间被称为 RTO（Retransmission Timeout），它在根据 RTT（Round Trip Time）通过一定的算法计算得来的。在 TCP 的实现中，第一次设置的定时器超时时间为 RTO，如果触发超时以后，下一次为本报文段设置的定时器超时时间会变为 2RTO，如果再次触发，则下一次会是 4RTO，每次会比上一次翻倍。&lt;br&gt;
　　之所以这样实现，是因为 TCP 考虑到丢包很可能是因为发送方和接收方之间的一台或多台路由器上有太多数据包来不及处理，如果在短时间内继续重传，不仅依然收不到，而且可能会导致拥堵问题更加严重。&lt;br&gt;
　　在弱网情况下，这个每次翻倍的机制可能就会拖累用户的使用体验。并且弱网下的丢包大部分情况下都是因为硬件的信号问题，而不是线路上路由器拥堵。所以一般 RUDP 的实现会把这个倍率调低，通过更加频繁的重发，尝试将报文成功发送出去。&lt;br&gt;
　　但是需要注意的是，如果确实是因为线路拥堵的原因导致的丢包，那么调低倍率 RTO 倍率并不会带来任何好处，不仅多浪费了流量，而且还让线路更加拥堵了。&lt;/p&gt;
&lt;h3 id=&#34;差错恢复&#34;&gt;差错恢复&lt;/h3&gt;
&lt;p&gt;　　网络数据流中处理差错恢复的方法主要有：回退 N 步（Go Back N，GBK）和选择重传（Selective Repeat，SR）这两种。TCP 的实现是把这两种混合在一起的。&lt;br&gt;
　　这里先不展开讨论这几种差错恢复的全部区别，只把重点放在数据重传上。&lt;br&gt;
　　GBN 的接收端不设置缓存，失序报文全部丢掉，返回最后确认的 ACK。如果某个序号为 n 的报文段在发送过程中丢失了，它会把包括 n 在内的所有 n 以后的已发送的报文全部重发一次。&lt;br&gt;
　　SR 中每个报文段相对独立，如果一个报文段在发送中丢失了，那么它自己的定时器超时以后只会重传它自己即可。&lt;br&gt;
　　TCP 一般的实现中会在接收端缓存失序到达的报文段，并且在收到失序报文时会给发送端回复一个冗余 ACK，三次冗余 ACK 以后会触发 TCP 的快速重传机制，让发送端立即重发缺失的报文段。接收端在收到缺失的报文段以后，会在缓存中查找后续的报文段，根据缓存中的情况，直接返回给发送端最新的 ACK 即可。&lt;br&gt;
　　RUDP 的实现一般不太一样，以 KCP 为例，它采用了 SR 的策略，并且接收端不会传冗余 ACK，而是由发送端根据接收到的后续的 ACK 来判断某个报文是否丢失了，从而发起快速重传。&lt;/p&gt;
&lt;h3 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h3&gt;
&lt;p&gt;　　如果说前面的都是小问题的话，那么 TCP 的拥塞控制可能就是 RUDP 大行其道的最大原因了。&lt;br&gt;
　　拥塞控制是 TCP 的一套试探线路负载上限的策略，包括了慢启动，拥塞避免和快速恢复三种可以互相转化了状态。&lt;br&gt;
　　慢启动，是指 TCP 会以 1 个 MSS 为拥塞窗口，逐步向上增加，每次收到一个新的 ACK 时就增加一个 MSS，看起来是好像时线性增加其实是指数增长的，因为如果网络没问题的话，下一次在一个 RTT 后会收到 2 个新的 ACK，会直接增加 2 个 MSS，同理下一次会增加 4 个 MSS。虽然增加的速度已经挺快了，但是一开始的速度会比较慢。&lt;br&gt;
　　如果在 TCP 中发生了超时丢包，都会将拥塞窗口重置为 1 个 MSS，并且 ssthresh（Slow Start Threshold，慢启动阈值）会被设为当前拥塞窗口的二分之一。在拥塞窗口超过了 ssthresh 以后，会进入到拥塞避免状态，每个 RTT 只能增加一个 MSS。同时如果发生的是由三个冗余 ACK 触发的丢包，那么 TCP 会将拥塞窗口变为原来的二分之一。&lt;br&gt;
　　可以看到在 TCP 中只要发生了丢包，都会倒是速率大幅下降，然后再慢慢升上来。&lt;br&gt;
　　同时 TCP 的拥塞控制秉承了公平性的原则，两条链接如果都要大量使用带宽的话，那么最终它们分到的带宽都接近带宽总量的二分之一。&lt;br&gt;
　　TCP 的拥塞策略是 RUDP 大量修改的地方，一般会改的激进很多，也不会完全遵循公平原则。不单是 RUDP，谷歌搞得 bbr 已经被合并到了 Linux 新版内核里，也是为了修改拥塞控制。&lt;/p&gt;
&lt;h3 id=&#34;难修改&#34;&gt;难修改&lt;/h3&gt;
&lt;p&gt;　　为什么 TCP 有了这些问题，也有了明确的改进方向，但是并没有进行大刀阔斧的改革呢？&lt;br&gt;
　　主要是因为 TCP 是运行在内核态的协议，整个实现都在内核中。这就导致了它难开发，也难修改，因为不能把修改的部分简单的集成到客户端中。就算自己魔改了服务器上的 TCP 实现，但是用户的客户端 TCP 协议还是自带的实现，无法与魔改的实现兼容。即使是内核的实现也更新了，也还有大量运行着旧版内核的设备无法使用新特性。&lt;br&gt;
　　RUDP 基本上都是在用户态实现的，调试修改都很容易，也可以很简单的集成到客户端程序和服务器程序中，完全不需要改动内核，方便使用和更新。&lt;/p&gt;
&lt;h2 id=&#34;rudp-的问题&#34;&gt;RUDP 的问题&lt;/h2&gt;
&lt;h3 id=&#34;运营商-qos&#34;&gt;运营商 QOS&lt;/h3&gt;
&lt;p&gt;　　国内的一些地方的一些运营商，包括御三家，经常会对 UDP 数据进行限制，尤其是出国流量，轻则丢包，重则断连，可能完全无法使用。&lt;br&gt;
　　这样的情况导致 RUDP 很难作为单一协议使用，基本上还需要一份 TCP 的实现进行保底。&lt;br&gt;
　　为了解决这种情况，有一些特殊的办法。比如可以通过一些手段将 UDP 数据伪装成 TCP 数据。有一个开源项目 &lt;a class=&#34;link&#34; href=&#34;https://github.com/wangyu-/udp2raw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;udp2raw&lt;/a&gt; 就是针对功能这个实现的。或者通过发送冗余数据这种简单粗暴的方法，使用更多流量来对抗丢包，可以尝试使用 &lt;a class=&#34;link&#34; href=&#34;https://github.com/wangyu-/UDPspeeder&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;UDPspeeder&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;能耗&#34;&gt;能耗&lt;/h3&gt;
&lt;p&gt;　　由于 RUDP 都是运行在用户空间的，每一次的数据收发都需要进行上下文切换，而运行在内核空间的 TCP 的上下文切换会少很多。&lt;br&gt;
　　为了应对运营商的劣化，可能需要做的伪装也更加剧了 RUDP 的性能消耗。&lt;br&gt;
　　此外因为 TCP 已经作为主流协议使用几十年了，几乎任何需要使用网络的设备都会对 TCP 做各种软件硬件的优化，而这都是 RUDP 们不具备的，缺少优化也是现阶段 RUDP 能耗比 TCP 高的原因，可能需要 QUIC 这样强势的 RUDP 快速普及才会有好转。&lt;/p&gt;</description>
        </item>
        <item>
        <title>网络编程基础</title>
        <link>https://wmf.im/p/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Sun, 27 Mar 2022 20:18:47 +0800</pubDate>
        
        <guid>https://wmf.im/p/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;p&gt;　　网络编程是后端永远绕不开的话题，毕竟后端的存在就是为了给前端提供服务，而提供服务的方式就是网络。本篇会记录一些学习网络编程中碰到的基础知识。&lt;/p&gt;
&lt;h2 id=&#34;网络结构分层&#34;&gt;网络结构分层&lt;/h2&gt;
&lt;p&gt;　　对网络进行分层可以更加清楚的认识当前网络环境的运行状态。分层的方式有很多种，例如 OSI 的 7 层模型和 TCP/IP 的 4 层模型，本文会遵照 4 层模型的设计。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层（Application）：HTTP，SSH&lt;/li&gt;
&lt;li&gt;传输层（Transport）：TCP，UDP&lt;/li&gt;
&lt;li&gt;网络层（Internet）：IP&lt;/li&gt;
&lt;li&gt;链路层（Link）：网络硬件及其驱动程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　从上向下越来越接近底层。可以看到网络开发中经常打交道的 HTTP，TCP，UDP 这些协议都在比较靠上的层中。&lt;/p&gt;
&lt;h3 id=&#34;链路层&#34;&gt;链路层&lt;/h3&gt;
&lt;p&gt;　　链路层包括了网卡、网口这类硬件设备，同时也包括了硬件的驱动和硬件在操作系统的抽象。链路层为网络上的主机提供了硬件连接。&lt;br&gt;
　　链路层中传输的数据被称为帧（frame），不同链路层协议每帧可以传输的最大数据长度不同，这个长度被称为最大传送单元（Maximum Transmission Unit，MTU），帧在传输中可能经过不同协议的链路，其中最小的 MTU 被称为路径 MTU，超过路径 MTU 的数据链路层会直接丢弃，所以需要在上层做好分片。&lt;br&gt;
　　操作系统会为每个网卡提供缓冲区，在网卡启动的时候，会为它分配多个 RingBuffer 来作为接收队列和发送队列。&lt;br&gt;
　　当收到网络数据帧的时候，网卡会先把数据通过 &lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98%e8%ae%bf%e9%97%ae&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DMA&lt;/a&gt; 直接把数据写入到自己的接收队列中，超出队列长度的部分会被直接丢弃。&lt;br&gt;
　　当需要发送数据时，操作系统内核会将数据写入到网卡的发送队列中，网卡将发送队列中的数据发送出去，然后触发硬件中断清理掉发送队列的内容。&lt;/p&gt;
&lt;h3 id=&#34;网络层&#34;&gt;网络层&lt;/h3&gt;
&lt;p&gt;　　网络层运行在路由器和主机上，它为网络上的主机提供了逻辑连接。它主要提供的功能是转发和路由选择，前者由硬件实现，负责将数据从输入的链路层接口转发到合适的输出链路层接口，后者由软件实现，负责确定从源地址到目的地址的端到端路径的网络地址范围。&lt;br&gt;
　　网络层中我们主要看一下 IP 协议，它是本层中使用最广泛的协议。IP 协议是一个尽力交付协议，不保证交付，它分为 IPv4 和 IPv6 两种，目前都在使用中，并且会逐步实现从 IPv4 向 IPv6 的过渡。&lt;br&gt;
　　IPv4 的地址长度是 32 bit，一般采用点分十进制表示，每 8 个 bit 被分在了一段中，例如会使用 233.233.233.233 来表示 1110 1001 1110 1001 1110 1001 1110 1001。首部长度不固定，在 20 - 60 字节，不带有选项的典型首部长度是 20 字节。提供对数据分片和组装的功能。会使用首部校验和对首部的数据进行检查。&lt;br&gt;
　　IPv6 的地址长度是 128 bit，通常的表示格式会被分为 8 组，每组的 16 bit 使用 4 个十六进制数来表示，例如 2001:0db8:85a3:08d3:1319:8a2e:0370:7344 就是一个合法的 IPv6 地址。首部长度固定为 40 字节。它不提供分片功能，如果从链路层收到的数据在转发的时候超过了下一个链路层的 MTU，则 IPv6 会直接丢弃该数据报。同时它也不再提供首部的数据校验。&lt;/p&gt;
&lt;h3 id=&#34;传输层&#34;&gt;传输层&lt;/h3&gt;
&lt;p&gt;　　传输层为网络上的主机中的进程提供了逻辑连接，传输层的协议只在主机中实现，不会在路由器上实现，不管用什么协议，对路由器都是透明的。&lt;br&gt;
　　最常见的传输层协议是 TCP 和 UDP，TCP 为进程间提供了可靠，有连接的服务，UDP 提供的则是不可靠，无连接的服务。&lt;br&gt;
　　传输层通过多路复用和多路分解来把主机接收到的数据交付给指定的进程。&lt;/p&gt;
&lt;h3 id=&#34;应用层&#34;&gt;应用层&lt;/h3&gt;
&lt;p&gt;　　应用层的协议是基于传输层的协议实现的，一般都是把一些常见的开发需求实现成一个规范的协议，避免重复开发。&lt;br&gt;
　　比如 SSH 协议，如果完全按照它的规范实现一个服务端程序，那么市面上所有的 SSH 客户端就都可以直接拿来跟这个程序通讯，同理按照它的规范实现一个客户端程序，也可以跟市面上所有 SSH 服务端程序通讯。&lt;br&gt;
　　如果不使用通用协议，自己实现双端的协议也是可以的，这种非公开的协议一般被成为私有协议，使用私有协议通讯的软件也比比皆是，尤其是一些大公司的软件，比如微信这种。&lt;/p&gt;
&lt;h2 id=&#34;网络编程接口&#34;&gt;网络编程接口&lt;/h2&gt;
&lt;p&gt;　　《Unix 网络编程》里有一个我印象很深刻的例子，是说网络编程就像是打电话的步骤一样。服务端首先要买一台电话机（socket），然后要去运营商注册一个电话号码（bind），接着在电话旁边等待（listen），最后当电话响起的时候接听（accept）。客户端同样需要先买一台电话机（socket），然后注册号码（bind），最后打目标的电话（connect）。&lt;/p&gt;
&lt;h3 id=&#34;socket&#34;&gt;socket&lt;/h3&gt;
&lt;p&gt;　　socket 用来创建网络套接口的系统调用。调用的时候可以指定各种协议组合，返回的就是当前未使用的最小网络套接口的句柄。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;domain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// domain
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// AF_INET    IPv4
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// AF_INET6   IPv6
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// AF_LOCAL   Unix socket
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// type
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// SOCK_STREAM    字节流套接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// SOCK_DGRAM     数据包套接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// SOCK_NONBLOCK  非阻塞套接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// protocol
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// IPPROTO_TCP   TCP 传输协议
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// IPPROTO_UDP   UDP 传输协议
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　domain 表示套接口使用的协议域，type 是套接口的类型，protocol 是协议类型。其中前两个参数是一定需要的，第三个参数可以填 0 让内核使用前两个参数匹配的默认协议类型。比如 domain 填 AF_INET，type 填 SOCK_STREAM，protocol 填 0 或者 IPPROTO_TCP，这样创建的套接口就是最常用的 IPv4 TCP 类型。&lt;br&gt;
　　socket 函数默认情况下创建的套接口都是阻塞的，可以先创建好以后再修改，如果想要直接创建出一个非阻塞的套接口，那么可以使用 SOCK_NONBLOCK 参数，比如当我们把参数 type 设为 SOCK_STREAM | SOCK_NONBLOCK 就会创建出非阻塞的套接口。&lt;br&gt;
　　需要注意的是，内核可能会复用套接口描述字, 如果程序将套接口描述字保存下来的话，可能会碰到问题。比如一条连接早就关闭了，但是描述字一直保存在某个位置，当下次取出它想要发送数据的时候，它可能已经被内核复用，表示另一条连接了。&lt;br&gt;
　　内核在创建套接口的时候会为它创建缓冲区，有发送缓冲区和接收缓冲区，或者叫发送队列和接收队列。当执行 send 的时候，其实 send 只是把数据拷贝到了套接口的发送缓冲区中函数就返回了，具体的发送步骤依靠操作系统来安排。&lt;br&gt;
　　套接口在创建的时候可以设置是否阻塞，如果是阻塞的话，当发送缓冲区满了的时候，send 调用会被阻塞住，如果是非阻塞的，则当发送缓冲区满了的时候直接返回一个错误信息。同理 recv 调用在碰到接收队列是空的时候，也会进行类似的操作。&lt;br&gt;
　　如果接收缓冲区还有数据的时候，进程通过执行 close 关闭套接口，则会清空接收缓冲区并且发一个 RST 给对方，然后再开始四次挥手。如果发送缓冲区还有数据的时候，进程通过执行 close 关闭套接口，则会把四次挥手的 FIN 放在发送缓冲区的最后，也就是说内核会等发送缓冲区的内容发送完毕以后才开始四次挥手。&lt;/p&gt;
&lt;h3 id=&#34;套接口选项&#34;&gt;套接口选项&lt;/h3&gt;
&lt;p&gt;　　每个套接口可以有诸多选项，它们标识了套接口的功能和特性。一般使用 setsockopt 设置套接口的选项，使用 getsockopt 获取套接口的选项。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getsockopt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;optname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;optval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;optlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setsockopt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;optname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;optval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;optlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 返回值 0-成功 -1-失败
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// sockfd 打开的套接口描述字
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// level 指定协议
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// optname 选项的名字
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// optval get 的时候存结果，set 的时候放要设置的值。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// optlen 表示 optval 的长度。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　套接口选项的值为 0 则表示该选项没有开启，非 0 则表示选项已经开启。下面列出几个常用的套接口选项名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPPROTO_TCP - TCP_NODELAY，用来关闭 TCP 的 Nagle 算法，小包发送不做等待。&lt;/li&gt;
&lt;li&gt;SOL_SOCKET - SO_KEEPLIVE，保持连接存活。&lt;/li&gt;
&lt;li&gt;SOL_SOCKET - SO_REUSEADDR，套接口绑定的地址可以重复使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　使用 getsockopt 除了可以获取指定的选项的值以外，还可以获取套接口的错误信息。如果套接口发生了错误，内核会将 SO_ERROR 选项的值设为一个标准的错误代码，可以通过 strerror 来获取错误信息。&lt;/p&gt;
&lt;h3 id=&#34;io-阻塞类型&#34;&gt;I/O 阻塞类型&lt;/h3&gt;
&lt;p&gt;　　除了上文提到的可以在创建的时候直接通过 type 的参数设置套接口的阻塞类型外，还可以使用 fcntl 函数来修改一个套接口的阻塞类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fcntl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* arg */&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　参数 cmd 有两个最常用的值，F_SETFL 用来设置文件标志，F_GETFL 用来获取文件标志。但是需要注意的是，设置的时候会覆盖掉之前已经设置过的标志，所以一般的常规用法是先获取，然后修改当前值，然后再设置回去。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sp_nonblocking&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fcntl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F_GETFL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;fcntl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F_SETFL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;O_NONBLOCK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　这是 skynet 中设置套接口非阻塞的函数，就是 fcntl 的典型用法。&lt;/p&gt;
&lt;h3 id=&#34;bind&#34;&gt;bind&lt;/h3&gt;
&lt;p&gt;　　bind 可以将一个套接口描述字绑定到指定的 IP 和端口上。因为主机一般都有不止一个 IP，所以要指定一个具体的 IP 出来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 返回值 0 成功，-1 失败。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 参数可以直接用 getaddrinfo 的结果。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ip 和 端口都在 myaddr 结构中指定。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　如果传入的端口号为 0 的话，则内核会自动分配一个可用的端口号来进行绑定。如果传入的地址是 0.0.0.0 或者是 INADDR_ANY 的话，则内核可以自动绑定主机所有可用的地址。&lt;br&gt;
　　需要注意的是，bind 并不是一定需要的，不管是在服务端还是客户端，内核在处理没有 bind 的套接口时，会有一些辅助性操作。如果不调用 bind，直接对套接口描述字调用 listen 或者 connect 的话，效果和使用 INADDR_ANY 作为 IP，0 作为端口执行过 bind 是一样的，这一部分的内容可以参考 &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man7/ip.7.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;man 7 ip&lt;/a&gt;。&lt;br&gt;
　　有时候一些分布式进程并不需要指定端口，在 listen 获得端口以后，再上报自己的 IP 和端口给中心节点。&lt;/p&gt;
&lt;h3 id=&#34;listen&#34;&gt;listen&lt;/h3&gt;
&lt;p&gt;　　套接口分为主动套接口和被动套接口，主动套接口负责向外发送数据，被动套接口负责接收数据。使用 socket 创建好的套接口在默认情况下都是主动套接口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;backlog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 返回值 0 成功，-1 失败
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　通过对一个未连接的套接口描述字调用 listen 可以将其改变为被动套接口，内核可以接受一个指向被动套接口的连接请求，同时内核为每个被动套接口维护了两个队列：未完成连接队列和已完成连接队列。&lt;br&gt;
　　backlog 参数在 linux 中的意思是在等待 accept 的已完成连接的最大队列数量。不要设成 0，意义不明。如果超过了上限，会直接回一个 ECONNREFUSED 给客户端。内核对该参数的最大上限是在
&lt;code&gt;/proc/sys/net/core/somaxconn&lt;/code&gt; 中，新版内核的实现里该值为 4096。&lt;br&gt;
　　当客户端调用了 connect 以后，服务端收到了第一个 SYN 分节时，就会在未完成连接队列里创建一个新的项，一直到收到自己的 SYN 的 ACK 以后，也就是三次握手完毕以后，把该项从未完成连接队列移动到已完成连接队列的最后。&lt;br&gt;
　　半连接队列一般使用哈希表来实现，它的最大长度的计算方法是 min(backlog, somaxconn, tcp_max_syn_backlog) + 1 的结果再上取整到 2 的幂，但最小不能小于 16。&lt;br&gt;
　　半连接队列的价值是，如果每个 SYN 包内核都创建一个 sock 结构体的话，消耗太大了，所以在三次握手完成之前，内核只为每个 SYN 包创建一个很小的结构体 request_sock 来缓解这种情况，同时可以配合 &lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/SYN_cookie&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;syn_cookie&lt;/a&gt; 机制抵抗 &lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/SYN_flood&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SYN flood&lt;/a&gt; 攻击。&lt;br&gt;
　　已完成连接队列一般使用双向链表实现，长度是调用 listen 时传入的 backlog 和 &lt;code&gt;/proc/sys/net/core/somaxconn&lt;/code&gt; 之间较小的那个值。所有三次握手完毕但是还没有被 accept 调用的连接都在这个队列里。&lt;/p&gt;
&lt;h3 id=&#34;accept&#34;&gt;accept&lt;/h3&gt;
&lt;p&gt;　　accept 用来接受连接，它的实际操作就是从指定的被动套接口的已完成连接队列的最前面取得一个连接，并且返回它的描述字，后续可以通过这个描述字跟发起 connect 的客户端进行通信。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 成功，返回代表新连接的描述符，错误返回-1,同时错误码设置在errno
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;accept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　如果参数中传入的被动套接口描述字的已完成连接队列中并无连接，那么情况视套接口的阻塞模式而定。如果套接口是非阻塞的，那么直接返回错误，如果套接口是阻塞的，那么会一直等待已完成连接队列非空，拿到连接后才会返回。&lt;br&gt;
　　使用 accept 得到的套接口都是阻塞的，可以在拿到套接口描述字以后再将其设为非阻塞的，如果觉得麻烦，想要直接拿到非阻塞的套接字的话，可以使用 accept4 来操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;accept4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　使用 accept4 时，当 flags 传入 0 的时候，函数操作与 accept 完全一样。可以为 flags 传入 SOCK_NONBLOCK，这样得到返回的套接口就是非阻塞的。&lt;/p&gt;
&lt;h3 id=&#34;connect&#34;&gt;connect&lt;/h3&gt;
&lt;p&gt;　　connect 是客户端向服务端发起连接的接口，当它被调用时，会触发 TCP 的三次握手过程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt; &lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockaddr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socklen_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addrlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　需要注意的是，如果 connect 失败了，那么一定要关闭使用的套接口，再重新创建一个来进行下一次连接。&lt;/p&gt;
&lt;h3 id=&#34;close&#34;&gt;close&lt;/h3&gt;
&lt;p&gt;　　可以使用 close 来关闭一个套接口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　套接口描述字本身有一套引用计数机制，调用 close 只会将当前的引用计数 -1，并不一定会真的触发关闭操作。如果引用计数等于 0 的话，内核会尝试发送当前套接字的发送缓冲区中所有剩余的数据，并且在发送完成后，向对端发送 FIN 分节，开始四次挥手。&lt;/p&gt;
&lt;h3 id=&#34;套接口-io&#34;&gt;套接口 I/O&lt;/h3&gt;
&lt;p&gt;　　因为套接口描述字可以当作一个普通的文件描述字使用，所有有很多可以用来读写套接口的 I/O 函数，根据读写配对，有 read/write，readv/writev，recv/send，recvfrom/sendto，recvmsg/sendmsg 等，它们虽然参数不同，使用场景不太一样，但是功能是基本一致的，这里只写一下最常用的 read/write 好了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　read 会尝试从套接口的接收缓冲区中读取长度为 count 字节的数据，保存在 buf 指向的内存中。如果读取错误，会返回 -1 并且设置 errno。如果读取成功，则返回读取到的字节数，这个数字可能比 count 小，也有可能等于 count，比 count 小的原因可能是，接收缓冲区中并没有那么多数据，也可能是 read 在执行时被系统信号打断了。&lt;br&gt;
　　write 会尝试把 buf 指向的内存中的 count 字节写入到套接口的发送缓冲区中。如果写入失败，则会返回 -1 并且设置 errno。如果写入成功，则会返回写入的字节数，这个数量同样可能会小于等于 count，因为可能套接口的发送缓冲区没有了足够的剩余空间。&lt;/p&gt;
&lt;h2 id=&#34;epoll&#34;&gt;EPOLL&lt;/h2&gt;
&lt;p&gt;　　epoll 是 Linux 实现的一套高性能的 I/O 复用机制，因为它拥有远超 poll 和 select 的性能，所以它也是目前 Linux 平台上进行 I/O 复用开发最常用的机制。&lt;/p&gt;
&lt;h3 id=&#34;使用场景&#34;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;　　首先要了解 I/O 复用的使用场景。假设在服务器上有一个服务端程序，监听了一个端口，然后有很多客户端对这个进程发起了连接，这时候通过 accept 可以拿到大量的套接口。&lt;br&gt;
　　这些大量的已经连接的套接口，如何可以知道那个可读哪个可写呢？最笨的方法就是每隔一段时间遍历检查一遍所有的已连接套接口，检查它们的可读可写状态，进行操作。当套接口少的时候还可以这样，但是如果有很多很多套接口，这个方法的效率就很低。I/O 复用就是用来解决这个问题的。&lt;br&gt;
　　epoll 可以非常高效的管理很多套接口，用户可以对每个套接口设置关注的状态，然后每过一段时间检查 epoll 中就绪的套接口即可。&lt;/p&gt;
&lt;h3 id=&#34;创建-epoll-实例&#34;&gt;创建 epoll 实例&lt;/h3&gt;
&lt;p&gt;　　使用 epoll 的第一步是创建一个 epoll 实例出来，用于管理其它套接口。可以通过 epoll_create 和 epoll_create1 来创建 epoll 实例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/epoll.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;epoll_create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;epoll_create1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　epoll_create 的参数 size 在旧版本内核中是用来告诉内核为实例的数据结构划分的初始大小，不过在新版的内核中 size 已经没有实际意义了，随意填写一个不小于 0 的数字即可。&lt;br&gt;
　　epoll_create1 是内核提供的一个新的创建 epoll 实例的接口。它去掉了已经无用的 size，增加了一个 flags，这个 flags 可以设为 EPOLL_CLOEXEC，表示启动执行即关闭 (close-on-exec)。&lt;br&gt;
　　这两个函数返回的都是 int 类型，是代表了创建出的 epoll 实例的文件描述字。&lt;/p&gt;
&lt;h3 id=&#34;修改-epoll-的关注列表&#34;&gt;修改 epoll 的关注列表&lt;/h3&gt;
&lt;p&gt;　　有了 epoll 实例，下一步要修改它的关注列表了。可以使用 epoll_ctl 来为一个需要关注的套接口增加关注事件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/epoll.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;epoll_ctl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// op
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// EPOLL_CTL_ADD 增加关注事件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// EPOLL_CTL_MOD 修改关注事件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// EPOLL_CTL_DEL 删除关注事件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;          &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt;     &lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt;     &lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_data_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_event&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt;     &lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;      &lt;span class=&#34;cm&#34;&gt;/* Epoll events */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;epoll_data_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;        &lt;span class=&#34;cm&#34;&gt;/* User data variable */&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　参数 epfd 就是上一步中创建出来的 epoll 实例的描述字，op 代表操作，fd 代表关注的套接口描述字，event 代表关注的事件。&lt;br&gt;
　　data 的内容会在事件触发以后传给 epoll_wait 的返回值，可以用它保存一些在事件触发以后处理事件需要使用的数据。一般是需要记录下本描述字的，不然事件触发的时候会拿不到描述字。&lt;br&gt;
　　需要注意的是，当对一个描述字增加过关注事件以后，第二次想要增加需要使用修改才行。同时修改只能修改已经在关注列表中的描述字，也就是要先增加过关注事件才能修改。删除也是一定要当前存在关注列表中的，否则会报错。&lt;br&gt;
　　events 是一个掩码位，列举几个常用的选项。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位掩码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EPOLLIN&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;普通数据可读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EPOLLOUT&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;普通数据可写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EPOLLRDHUP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;套接口对端关闭&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;EPOLLET&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;采用边缘触发事件通知&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;等待-epoll-事件&#34;&gt;等待 epoll 事件&lt;/h3&gt;
&lt;p&gt;　　设置好 epoll 的事件关注列表以后，就可以等待事件发生了。使用 epoll_wait 来等待一个 epoll 实例上的事件发生。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/epoll.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;epoll_wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;epoll_event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxevents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;　　参数 epfd 就是 epoll 实例的描述字，events 用来接收触发事件的结果，maxevents 是 events 数组的长度，timeout 是等待的超时时间。&lt;br&gt;
　　如果调用成功，则返回值是就绪的描述字个数，同时 events 中包含了这些就绪描述字在使用 epoll_ctl 增加事件的时候传入的 event。&lt;br&gt;
　　timeout 如果设为 -1，则会一直阻塞，直到有一个描述字就绪。如果设为 0，则不阻塞，执行一次检测，不管有没有就绪的描述字都直接返回。如果大于 0，则在有任何描述字就绪的时候返回，如果一直没有，那么会最多阻塞在这里 timeout 毫秒的时间。&lt;/p&gt;
&lt;h3 id=&#34;触发模式&#34;&gt;触发模式&lt;/h3&gt;
&lt;p&gt;　　I/O 复用的事件触发模式可以分为两种，水平触发和边缘触发。&lt;br&gt;
　　水平触发指的是，只要当前事件仍然成立，就会返回就绪，比如套接口的接收缓冲区中有数据，那么每一次检查都会返回当前套接口可读。&lt;br&gt;
　　边缘触发是指，事件之前不成立，现在成立了，就会返回，一直到下一次再触发。即使缓冲区中的数据没有被读完，在下一次有新的数据进来之前检查也不会返回可读。&lt;br&gt;
　　select，poll 只支持水平触发，epoll 两种都支持，默认情况下使用的是水平触发，可以在增加事件关注列表时对某个套接口的事件使用边缘触发。&lt;br&gt;
　　可以看到如果使用边缘触发，那么就需要在收到一个事件以后，不断处理完它，因为再也不会有第二次检测到这个事件的机会了。同时使用边缘触发的话，最好搭配非阻塞套接口使用，因为需要不断读取直到没有数据，如果使用阻塞套接口会很麻烦。&lt;br&gt;
　　使用边缘触发的时候需要注意套接口饥饿的问题，因为如果一个套接口上有大量的数据，然后读取的时候使用无限循环的方式调用 read 去读的话，可能会在这一个套接口上花费大量时间，从而导致其它套接口上的数据一直得不到处理。有一种规避的方法是，记录下来所有触发过的套接口描述字，不立即读完其中的数据，而是每次对每个套接口读取一定长度的数据，不断遍历全部的可读套接口，如果某一个套接口上的数据已经读完了，就将它从数组中移除，一直这样直到所有就绪套接口都处理完毕。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
